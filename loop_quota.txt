создаем loop делаем его определенного размера, монтируем и получаем квоту

	loop кратко
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dd if=/dev/zero of=/tmp/file_fs count=65536 # Создадим файл 34Мб в temp
mke2fs -F /tmp/file_fs # Создаём там файловую систему
mkdir /mnt/ffs # Каталог для монтирования
mount -o loop /tmp/file_fs /mnt/ffs # Собственно монтирование


	loop подробнее
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dd if=/dev/zero of=/mnt/win_d/filesystem.ext bs=1024 count=350000
Таким образом мы создадим файл, состоящий из нулей (т.к. используется /dev/zero) на разделе, подмонтированном к /mnt/win_d. Крайне рекомендуется при создании нового файла использовать размер блока (bs) равный 1024. Это значительно ускоряет операцию создания файла. При bs=1 на моем компьютере файл создавался около 10 минут.


Создаем файловую систему.В этом примере создается файловая система second extended (EXT2).
mkfs.ext2 /mnt/win_d/filesystem.ext

Еще раз отмечаю, что "гостевая" файловая система (в которой создается наш файл) и собственно создаваемая файловая система могут быть любого поддерживаемого ядром типа.


Монтирование.
mount -o loop /mnt/win_d/filesystem.ext /mnt/virtual

Здесь необходимо обратить внимание на опцию loop команды mount. Таким образом мы присоединяем наш файл-файловую систему к первому свободному устройству /dev/loopX Проверено для двух устройств. Первое монтируется к /dev/loop0, второе - к /dev/loop1. 


Что такое losetup и как этим пользоваться.
Все изложенное выше правильно, но есть и другой вариант монтирования нашего "файла". Имеется в виду утилита losetup, которую можно найти практически в любом дистрибутиве GNU/Linux. losetup специально предназначена для присоединения "нестандартной" файловой системы (в виде файла, в частности) к устройствам /dev/loopX.
Делается это таким образом:
losetup /dev/loop0 /mnt/win_d/filesystem.ext

Теперь обращаясь к устройству /dev/loop0 (в том числе смонтировав его), мы будем обращаться к нашему файлу (то есть файловой системе) на /mnt/win_d/filesystem.ext
Теперь можно смонтировать устройство:
mount /dev/loop0 /mnt/virtual
Эти операции дают тот же эффект, что и в первом случае (mount -o loop /mnt/win_d/filesystem.ext /mnt/virtual).
losetup, однвко имеет несколько приятных особенностей. В частности, эта утилита позволяет шифровать данные в нашей файловой системе по алгоритму AES и установить пароль на доступ к ней. Особого внимания заслуживает опция offset. Кроме того, можно использовать gnupg для дополнительного шифрования данных ПЕРЕД тем как они попадут в нашу файловую систему. Вероятно, это можно сломать... Лет через сто.  В этом состоит одно из преимуществ использования losetup по сравнению с обычным mount.


Автоматизация.
Для того, чтобы созданная нами файловая система была доступна при каждой загрузке системы автоматически, необходимо добавить соответствующие изменения в конфигурацию системы.
В нашем примере достаточно будет добавить одну строку в /etc/fstab для того чтобы наша файловая система монторовалась как любое другое устройство.
Выглядеть эта строка будет так:
/mnt/win_d/filesystem.ext /mnt/virtual ext2 loop 0 0

Теперь наша файловая система будет доступна из каталога /mnt/virtual сразу после старта системы.


	loop еще один вариант
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Листинг 1. Создание инициализированного файла
dd if=/dev/zero of=file.img bs=1k count=10000

Теперь у нас есть файл file.img размером 10 МБ. Свяжем с файлом блочное устройство-заглушку (loop) с помощью команды losetup (чтобы он выглядел как блочное устройство, а не как обычный файл файловой системы):
losetup /dev/loop0 file.img

Теперь, имея файл, который выглядит как блочное устройство (представлен /dev/loop0), создадим на этом устройстве файловую систему с помощью mke2fs. Эта команда создает новую файловую систему ext2 определенного нами размера
Создание файловой системы ext2 на устройстве loop

mke2fs -c /dev/loop0 10000
mke2fs 1.35 (28-Feb-2004)
max_blocks 1024000, rsv_groups = 1250, rsv_gdb = 39
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
2512 inodes, 10000 blocks
500 blocks (5.00%) reserved for the super user
...

Теперь файл file.img, представленный блочным устройством (/dev/loop0), смонтирован в точке /mnt/point1 с помощью команды mount. Обратите внимание, что указанный тип файловой системы - ext2. После монтирования вы можете обращаться к точке монтирования как к новой файловой системе с помощью команды ls
Создание точки монтирования и монтирование файловой системы посредством устройства loop

mkdir /mnt/point1
mount -t ext2 /dev/loop0 /mnt/point1
ls /mnt/point1
lost+found

Как показано в листинге 4, этот процесс можно продолжить, создавая новый файл в новой файловой системе, связывая его с устройством loop и создавая в нем еще одну файловую систему.

Создание новой файловой системы loop в уже существующей

dd if=/dev/zero of=/mnt/point1/file.img bs=1k count=1000
1000+0 records in
1000+0 records out
losetup /dev/loop1 /mnt/point1/file.img
mke2fs -c /dev/loop1 1000
mke2fs 1.35 (28-Feb-2004)
max_blocks 1024000, rsv_groups = 125, rsv_gdb = 3
Filesystem label=
...
mkdir /mnt/point2
mount -t ext2 /dev/loop1 /mnt/point2
ls /mnt/point2
lost+found
ls /mnt/point1
file.img lost+found

Из этого простого примера легко понять, насколько большие возможности предоставляет файловая система (и устройство loop) в Linux. Аналогичным образом с помощью устройства loop можно создавать в файле файловые системы с шифрованием. Это может быть полезно для защиты ваших данных; при необходимости такой файл можно быстро смонтировать с помощью устройства loop.


	пакет quota
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
а) для систем на базе RPM (Red Hat, CentOS):
yum install quota

б) для систем на базе deb (Debian, Ubuntu):
apt-get install quota

Настройка раздела
Для возможности управлять квотами для определенного раздела необходимо его смонтировать с соответствующими опциями. Для файловых систем XFS и не XFS (например, ext) эти опции различаются:

Для XFS — uquota (для пользователей) и/или gquota (для групп).
Для ext и других — usrquota (для пользователей)и/или grpquota (для групп).
И так, чтобы добавить нужные опции для включения квотирования, откроем файл fstab:

vi /etc/fstab

Находим настройку для монтирования раздела, на который необходимо установить квоту и добавим нужные опции:

/dev/sda     /     ext4     defaults,usrquota,grpquota     0 0
/dev/sdb     /var     xfs     defaults,uquota,gquota     0 0

* в данном примере мы добавили опции usrquota и grpquota для устройства /dev/sda, примонтированного в качестве корневого раздела / с файловой системой ext. А также опции uquota и gquota для устройства /dev/sdb (монтируется в /var с файловой системой xfs). Если необходимо включить квоту только для пользователей или групп, оставляем соответствующие опции.
* существуют и другие опции, например, jqfmt нужна для указания формата квоты при использовании журналирования.


Перемонтируем наши разделы:
mount -o remount /
mount -o remount /var

Проверим, что нужные нам разделы теперь смонтированы с опциями квотирования:
mount | grep quota

Мы увидим, примерно, следующее:
/dev/sda on / type ext4 (rw,relatime,quota,usrquota,grpquota,data=ordered)
/dev/sdb on /var type xfs (rw,relatime,attr2,inode64,usrquota,grpquota)

Квоты включены для разделов.

Корневая директория (/) + XFS
При попытке включить квоту для корневой директории XFS с помощью файла fstab, результат будет нулевым — в опциях монтирования мы будем наблюдать noquota, например:
/dev/sda on / type xfs (rw,relatime,attr2,inode64,noquota)

Для включения опции квотирования необходимо отредактировать загрузчик. Для этого открываем файл:
vi /etc/default/grub

Находим строку GRUB_CMDLINE_LINUX и дописываем в нее rootflags=uquota,gquota — в моем случае получилось так:
...
GRUB_CMDLINE_LINUX="crashkernel=auto rd.lvm.lv=vg/root rd.lvm.lv=vg/swap rhgb quiet floppy.allowed_drive_mask=0 rootflags=uquota,gquota"
...

На всякий случай, сохраним конфигурационный файл загрузчика:
cp /boot/grub2/grub.cfg /boot/grub2/grub.cfg.backup
... и применим настройки grub:
grub2-mkconfig -o /boot/grub2/grub.cfg

Перезагружаем компьютер:
shutdown -r now

После перезагрузки мы должны наблюдать такую картину:
mount | grep quota
/dev/mapper/vg-root on / type xfs (rw,relatime,attr2,inode64,usrquota,grpquota)
Квоты включены для корневого раздела с файловой системой XFS.


Включение квот
И так, мы разрешили квоты для разделов. Теперь включаем квоты. Процессы для XFS и остальных файловых систем немного различаются. Мы рассмотрим оба варианта. Так как в нашем примере есть разделы для XFS и Ext, то мы выполним все варианты настроек.

XFS
После монтирования раздела с файловой системой XFS автоматически включается квотирование (если была задана соответствующая опция). Проверить состояние можно, войдя в режим экспертного управления квотами:
xfs_quota -x
... и выполнив команду для получения статуса:
> state

Ext и другие
Выполним проверку наличия служебных файлов aquota.user и aquota.group — если их нет, команда их создаст автоматически:
quotacheck -favugm
... при наличии разделов с включенной квотой на XFS мы можем увидеть:
quotacheck: Skipping /dev/sdb [/var]

* это нам говорит о том, что команда quotacheck пропускаем раздел с xfs.

Включаем квоту для разделов:
quotaon -avug

Установка квот
Пришло время задать квоты. Они устанавливаются с помощью команды edquota.

Квоты пользователей
Для пользователя, вводим команду:
edquota -u dmosk

* где dmosk — имя пользователя, для которого будет задана квота.

В открывшемся редакторе можно задать ограничение на использование разделов, для которых включена квота:
Disk quotas for user dmosk (uid 1001):
  Filesystem    blocks    soft    hard    inodes    soft    hard
  /dev/sda          20       0     10M         8       0       0
  /dev/sdb           0       0     20M         0       0       0

* где:

Filesystem — дисковое устройство, для которого устанавливается квота.
blocks — текущее количество используемых пользователем блоков.
первый soft — мягкая квота на объем данных (при ее превышении отправляется уведомление по почте, а после периода отсрочки, который по умолчанию составляет 7 дней, мягкая квота становится жесткой).
первый hard — жесткая квота на объем данных (при ее превышении дальнейшая запись будет запрещена).
inodes — текущее количество файлов, используемых пользователем.
второй soft — мягкая квота на количество файлов (при ее превышении отправляется уведомление по почте).
второй hard — жесткая квота на количество файлов (при ее превышении дальнейшая запись будет запрещена).
* в данном примере мы задали жесткую квоту для пользователя dmosk в 10 Мб на /dev/sda (корневой раздел) и 20 Мб на /dev/sdb (/var).

Квоты для групп
Для группы, задаем квоту так:
edquota -g mail

Как и в случае с пользователем, откроется редактор, с помощью которого можно задать квоту:
Disk quotas for group mail (gid 12):
  Filesystem    blocks    soft    hard    inodes    soft    hard
  /dev/sda           0       0     30M         6       0       0
  /dev/sdb           0       0     40M         0       0       0

* в данном примере мы зададим квоту для группы в 30 Мб на /dev/sda (корневой раздел) и 40 Мб на /dev/sdb (/var).

Копирование квот
Мы также можем копировать квоты для пользователей. Для этого используется та же команда edquota с ключом -p:
edquota -p dmosk ivanov
* в данном примере мы скопируем настройку квотирования, которая применяется к dmosk на другого пользователя ivanov.

Настройка периода отсрочки
Как было упомянуто выше, мягкие ссылки являются мягкими только в течение периода отсрочки. Данный период по умолчанию равен 7 дням. Его можно задать командой edquota с ключом -t:
edquota -t

В открывшемся окне задаем новые значения:
Grace period before enforcing soft limits for users:
Time units may be: days, hours, minutes, or seconds
  Filesystem             Block grace period     Inode grace period
  /dev/mapper/vg-root                  8days                  9days
  /dev/sdb                      8days                  9days
* в данном примере мы задали 8 дней для квот на дисковое пространство и 9 дней — на количество файлов.

Просмотр и проверка квот
Ограничения настроены. Проверим...

Отчет по квотам
Чтобы посмотреть отчет об используемом пространстве и установленных квотах, вводим команду:
repquota -us /
* для отчета корневого раздела только по пользовательским (u) квотам в режиме удобного чтения (s).
... и:
repquota -g /var
* для отчета по разделу /var для групп.
Мы увидим что-то на подобие:

*** Report for user quotas on device /dev/sda
Block grace time: 7days; Inode grace time: 7days
                        Block limits                File limits
User            used    soft    hard  grace    used  soft  hard  grace
----------------------------------------------------------------------
root      --   2862M      0K      0K           115k     0     0       
polkitd   --      0K      0K      0K              2     0     0       
tss       --      8K      0K      0K              2     0     0       
postfix   --      4K      0K      0K             38     0     0       
chrony    --      4K      0K      0K              3     0     0       
dmosk     --     20K      0K  10240K              8     0     0       
rpc       --      0K      0K      0K              2     0     0       
ntp       --      4K      0K      0K              3     0     0       
...

* как видим, это отчет по использованию раздела /. Мы видим, каким пользователем сколько занято дискового пространства и видим, что для нашего пользователя dmosk установлена квота в 10 Мб (10240 Кб).

Проверка
И так, мы настроили для пользователя dmosk ограничение на использование дискового пространства. Попробуем превысить данный лимит. Заходим в консоль под нужным пользователем:
su - dmosk
... и вводим:

dd if=/dev/zero of=/tmp/tmp_dmosk_file bs=1024000 count=100
* команда должна создать файл на 100 Мб в каталоге tmp.

Однако, система вернет сообщение:
dd: ошибка записи «/tmp/tmp_dmosk_file»: Превышена дисковая квота
11+0 записей получено
10+0 записей отправлено
 скопировано 10240000 байт (10 MB), 0,223768 c, 45,8 MB/c

Квота работает.

Другие квоты
Иногда, необходимо установить квоту в рамках определенной программы или каталога.
Однако, квоты так не работают и нет возможности задать их для определенного каталога или программы. Но это не означает, что выхода нет.

Квота на директорию
Чаще всего, нет необходимости задавать квоту на всю систему — нужно только ограничение размера директории. В данной ситуации нам нужно примонтировать диск к нужной директории и задать квоту на примонтированный раздел.

Квоты в samba
Как правило, речь в контексте samba идет о ограничения на использование шары. Для этого необходимо каждую шару поместить на отдельный раздел, каждый со своей квотой.

Также в файловом сервере samba есть возможность настройки квотирования на уровне программного обеспечения. В конфигурационном файле при настройке шары добавим:

[share]
  ...
  vfs objects = default_quota
  default_quota:uid = 1022
  default_quota:uid nolimit = no
  ...
* в данном примере мы задаем квоту на каталог share. Данная квота должна быть такой же, как у системного пользователя с uid 1022. Таким образом, системные квоты должны быть настроены.

Для samba есть также параметр max disk size, который не является ограничением, а просто показывает для других программ максимальный объем доступного пространства.

Квоты в vsftpd
Настраивая vsftpd, мы также должны позаботиться о том, чтобы каталоги с FTP были на разделах с установленными квотами. Другими словами — вопрос также решается с применением пакета quota.





	монтируем раздел fstab
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
создаем директорию куда будем монтировать  mkdir -p /mnt/backup
даем ей права chmod 777 /mnt/backup 
нужно прописать в fstab строчку для автоматического монтирования lvm — для начала смотрим идентификатор

blkid
/dev/sdb1: UUID="6eLRc0-ZsAZ-ANKi-pPKg-hGRV-q0eY-zMcHDX" TYPE="LVM2_member" PARTUUID="00017060-01"
/dev/sdc1: UUID="f4f0dd7c-0603-4c5b-8566-f5fc1100a557" TYPE="ext4" PTTYPE="dos" PARTUUID="00024c52-01"
/dev/sdc2: UUID="26406f24-04ab-4044-b5b9-7eb22e089c0c" TYPE="ext4" PARTUUID="00024c52-02"
/dev/sdc3: UUID="9a623777-c473-41f5-945e-1987e49581e1" TYPE="ext4" PARTUUID="00024c52-03"
/dev/sdc4: UUID="bfa403a4-5769-4b1b-acf6-48e0c52eb8d7" TYPE="swap" PARTUUID="00024c52-04"
/dev/sr0: UUID="2017-07-19-16-46-54-00" LABEL="openSUSE-Leap-42.3-DVD-x86_64033" TYPE="iso9660" PTUUID="1b681c50" PTTYPE="dos"
/dev/sda1: UUID="VipY6S-QcOq-oR5U-UgaU-yz9g-XSWg-JsY7I1" TYPE="LVM2_member" PARTUUID="000686d1-01"
/dev/mapper/backupdisks-copysdisk: LABEL="backup" UUID="38B56B6D63415A3D" TYPE="ntfs"

нам нужен последний
/dev/mapper/backupdisks-copysdisk: LABEL="backup" UUID="38B56B6D63415A3D" TYPE="ntfs"

редактируем fstab
nano /etc/fstab
строки есть изначально:
UUID=bfa403a4-5769-4b1b-acf6-48e0c52eb8d7 swap                 swap       defaults              0 0
UUID=f4f0dd7c-0603-4c5b-8566-f5fc1100a557 /                    ext4       acl,user_xattr        1 1
UUID=26406f24-04ab-4044-b5b9-7eb22e089c0c /home                ext4       acl,user_xattr        1 2
UUID=9a623777-c473-41f5-945e-1987e49581e1 /var                 ext4       acl,user_xattr        1 2

мы дописываем свою:
UUID=38B56B6D63415A3D /mnt/backup    ntfs         default       0 0

UUID=38B56B6D63415A3D — идентификатор диска
/mnt/backup — куда подмонтируем нашlvm
ntfs — файловая система на LVM
default — пойии монтирования файловой системы, другие не подошли
0 0 — первый делать или нет резервную копию, второй порядок проверки раздела 0 не проверять, 1 устанавливается для корня, 2 для остальных разделов


