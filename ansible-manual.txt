Ansible
-приведение к состоянию, принцип идемпотентности - если это уже сделано, то повторно не делается, 
не рекомендуется использовать и модуль который обращается к шелл напрямую, ну или с осторожностью

(несколько начальных моментов будет и для linux и для windows, а после
только для linux)


все программки делятся на 2 типат pull и push

pull - на управляемых серверах поставить агент, это самое начало
       придется делать руками - делать логин на каждый сервер и 
       установить туда agent

push - Ansible относится к ним - на управляемых серверах ничего не нужно
       устанавливать - "Ansible мастер" делает на сервера push (запихивает
       на сервер настройки сам)



Ansible мастер - компьютер на котором установлен Ansible (только один компьютер)
еще могут называть Control server
мин требования:  
1. Red had/Debian/Ubuntu/Centos/OS X (только linux, на windows не работает)
2. Python2.6+ или Python3.5+


Controlled servers (managed servers) - управляемые компьютеры (клиенты)

1. для linux нужны всего админский логин и пароль или ssh key и Python2.6+
работа через протокол ssh (т.е. открыт порт 22)

2. для windows - тоже даминский логин/пароль, powershell 3.0, но для многих
команд версия powershell должна быть выше 3.0 и еще запустить скрипт на 
power shell - ConfigureRemotingForAnsible.ps1
работа через WinRM  д.б. открыт порт 5986


Установка:
зайти на сайти там посмотреть, воможно будут какие то изменения
https://docs.ansible.com/
https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#latest-release-via-yml

не забываем, что нам нужен еще и python, он может быть уже установлен, нужно проверить

для Centos 7
Добовляем репозиторий
yum install epel-release

yum update

установка
yum install ansible

проверяенм версию
ansible --version


для Ubuntu
Добовляем репозиторий
apt-add-repository ppa:ansible/ansible

apt update

установка
apt install ansible

проверяенм версию
ansible --version



сейчас некоторое неудобство - будем использовать Amazon linux
но думаю это не создаст проблем

устанавливаем Мастера
pip install ansible    (да, через питона)


проверяенм версию
ansible --version

минус установки через питон - не создается конфиг файл
а если устанавливаем обычным способом, например (apt install ansible
в ubuntu) - то конфиг есть



Подключение Ансиблом:
Подключаться лучше через  ssh ключ

копируем ключи к себе на Мастер Ansible
файлы   ******-key.pem

дальше, для безопасности можно изменить на ключи права
chmod 400   ******-key.pem


создаем и заходим в директорию
mkdir ansible/
cd ansible

создадим директорию inventory и в ней файл hosts
так же может сожержать и логины с паролями, но это опасно
поэтому для паролей используем vault
hosts    -- это некий аналог днс

в него запишим адреса наших хостов и в прямых скобках группы

[stading_servers]   --так обозначается группа
linuxX   ansible_host=172.31.8.69   ansible_user=ec2-user   ansible_pass=Qwerty123
linuxXX   ansible_host=172.31.8.68   ansible_user=ec2-user   ansible_ssl_private_key_file=/home/ec2-user/.ssh/ourkey1.pem

при первом подключении к серверу - сервер может запросить fingerprint - нужно напечатать yes и жать ентер
в некотором случае при выполнении плэйбука может случиться ошибка, тут просто берем и подключаемся к
хосту руками через ssh (мы же не по паролю подключаемся), проходим fingerprint и разлогиниваемся,
потом повторно перезапускаем наш плэйбук

запускаем на выполнение
ansible -i hosts all -m ping

ansible   --запуск на выполнение
-i hosts  --какой файл инвентори мы используем  
all       --на каких серверах запускаем, в этом случае на всех, но можно на одном
          или на отдельной группе
-m ping   --модуль пинг (в ручном запуске почти всегда будет -m и имя модуля)



создадим в нашем hosts еще одну группу серверов
[prod_servers]
linux1   ansible_host=172.31.27.16   ansible_user=ec2-user   ansible_ssl_private_key_file=/home/ec2-user/.ssh/ourkey1.pem
linux2   ansible_host=172.31.19.188   ansible_user=ec2-user   ansible_ssl_private_key_file=/home/ec2-user/.ssh/ourkey1.pem

чтобы обойти fingerprint  - создадим конфиг
проверяем есть ли этот файл

ansible --version

и если вторая строчка будет
config file = none

то никакого конфига у нас нет, мы его создадим и будем держать его в нашем проекте
nano ansible.cfg

впишем следующее

[defaults]                    --это самая первая строчка, д.б. всегда
host_key_checking = false     --отменяем проверку на fingerprint   (все значения на офиц сайте)
inventory         = ./hosts   --чтобы больше не писать ansible -i host, чтобы он сам знал, где брать файл

сейчас у нас в корне ansible лежат два файла - hosts - наш "днс" и файл с конфигом

так же можно вставить строку большими буквами,только false строчными, перед ansible-playbook
ANSIBLE_HOST_KEY_CHECKING=false

вот что получается:
ANSIBLE_HOST_KEY_CHECKING=false ansible-playbook -i ./inventory/hosts ......

и запускаем пинг на всех серверах, сейчас нужно только указать на каких серверах и какой модуль

ansible all -m ping

all       --на всех серверах
-m ping   --модуль пинг


еще пример файла hosts и запуска, но этот пример еще рано давать для запуска, но пусть он тут будет
---
all:
  spb:
    hosts:
       spb-host1.com:
       spb-host2.com:
    vars:
       master:spb-host-master.com:
   msk:
    hosts:
       msk-server[1-5].com

и сам запуск плэйбука
--check    --тестирует выполнение и НИЧЕГО!! не изменяет, рекомендуется выполнять первый запуск с этим параметром
ansible-playbook -i ./inventory/hosts --limit "msk-server1.com" --check --private-key ~/.ssh/my_private_key.pem --ask-vault-pass ./init.yml --tag роль

ansible-playbook                           --запуск плэйбука
-i ./inventory/hosts                       --указываем гда лежит hosts
--limit "msk-server1.com"                  --для какого хоста применять роль
--check                                    --параметр для проверки - если он есть, ничего меняться и 
                                           применяться не будет
--private-key ~/.ssh/my_private_key.pem    --путь до нашего ключа
--ask-vault-pass                           --спрашивать пароль у хранилища (он там зашифрован)
./init.yml                                 --сам плэйбук, которую запускаем
--tag "роль"                               -- выполнить отлько эту роль из всего плэйбука - "роль" - название 
                                           роли, если не указывать плэйбук применится весь 




установка Мастера Amazon linux или через pip на любых linux (где есть pip)

pip install ansible

но при установке через pip не создается конфиг файл, но всегда можно создать конфиг руками



подключение к серверам linux

подчключаться будем используя ключи

для начала копируем ключи (*.pem) на Мастер в нашу домашн. директорию
и для безопасности можно изменить у них права
chmod 400 наш-ключ.pem

опять повторим, нам нужно создать директорию, пусть ansible перейдем в нее и создадим
hosts  файл - файл inventory который содержит хосты и группы (напоминает днс) сл содержания:

[stading_servers]       --так обозначается группа
linuxX  ansible_host=172.31.8.69 ansible_user=ec2-user   --наш пользователь для подключения
   (продолдаем эту же строчку) ansible_ssh_private_key_file=/home/ec2-user/.ssh/california+key1.pem
                                ansible+pass=mypass     --если используем пароль, а не ключ ssh
                                 

пробуем запустить файл

ansible -i hosts all -m ping   --запустить на всех серверах пинг

дополним наш инвентори

[prod_servers]
linux1  ansib_lehost=172.31.27.16 ansible_user=ec2-user ansible_ssh_private_key_file=/home/ec2-user/.ssh/california+key2.pem

linux1  ansib_lehost=172.31.38.188 ansible_user=ec2-user ansible_ssh_private_key_file=/home/ec2-user/.ssh/california+key2.pem


чтобы убрать fingerprint:
1. сделать конфиг  -  ansible.cfg


смотреть,есть ли конфиг
ansible --version   --если есть конфиг - он покажется (вторая стр)
содержимое конфига

[defaults]
host_key_checking = flse                  --отмена проверки
iunventory        = ./hosts               --
--файл чтобы кажд раз не писать ansible

inventory =./hosts                        --чтобы не прописвать "ansible -i hosts"

2. написать впереди заглавными!:
ANSIBLE_HOST_KEY_CHECKING=falce   --а false строчными



      как подключаться к windows
ВАЖНО - сейчас аунтификацию мы делаем локальными пользователями (basic auntification)
для AD нужно использовать или Kerberos, или TNLM, или CredSSP

на ansible master нужна библиотека winrm
изменить hosts файл
на win серверах нужно сделат ь enable winrm

устанавливаем winrm

sudo pip install "pywinrm>=0.2.2"     --версия больше или равно 0.2.2

на нашем мастере модифицируем hosts
делаем новую группу 

[windosw_servers]
                   и добавляем сервера
windows2012  ansible_host=172.31.4.99
windows2016  ansible_host=172.31.13.170
                   если у нас одинаковые параметры для целой группы (имя и пароль
                   например), то можно их прописать в другом есте, не как в прошл 
                   раз. для этого пишем название группы
                   (в данном! файле все писать через = (равно), а не двоеточие)
[windosw_servers:vars]
ansible_user=myadmin
ansible_password = advit1234%          --в чистом виде никогда пароли не пишем
ansible_port = 5986                    --нужно для windows
ansible_connection = winrm             --нужно для windows
ansible_winrm_server_cert_validation = ignore     --нужно для windows

ВАЖНО - сейчас аунтификацию мы делаем локальными пользователями (basic auntification)
для AD нужно использовать или Kerberos, или TNLM, или CredSSP

идем в браузер, набираем ansible for windosw, заходим на офиц сайт
docs.ansible.com/ansible/latest/intro_windows.html
и читаем,
там же находим некоторый скрипт на PS который нужно запустить
example/scripts/ConfigureRemotingForAnsible.ps1

его нужно скачать и запустить на ВСЕХ windows машинах как Администратор
(т.е. запустить PS как администратор и в ней уже запустить скрипт)

должен выдать "Ок"

(если машин много и есть DC - добавить в group policy)

теперь пробуем пингануть

ansible windosw_servers -m win_ping

windosw_servers      --наша группа
-m win_ping          --название модуля - внимание на приписку win
                       почти все виндовые модули начинаются с win_

если мы НЕ ХОТИМ СВЕТИТЬ ПАРОЛЕМ, то убираем переменную отвечающ за пароль
из нашего hosts файла
и наша строка будет такой

ansible windosw_servers -m win_ping --ask-pass



   вернемся к linux
создание файла inventory  (сейчас его роль исполняет наш hosts)

сервера можно описывать не символьным именем, а ip, или доменные имена
webserver.google.com

или нам ранее привычнее через алиас
webserver ansible_host=10.20.130.140

у нас есть группа которой принадлежат все сервера -all
а есть ungrouped - все сервера которые не входят ни в одну группу
(отдельно прописанные)

ВАЖНО - АНСИБЛ ЧУВСТВИТЕЛЕН К РЕГИСТРУ


добавим в наш файлу hosts нескалько групп
(так же рекомендовано разделять сервера на группы)

10.50.1.1
10.51.1.2

[staging_DB]
192.168.1.1
192.168.2.2

[staging_WEB]
192.168.2.1
192.168.2.2

[staging_APP]
192.168.3.1
192.168.3.2

//а теперь создадим группу которая включит все вервера от групп
staging (т.е. включит в себя другие группы)


[staging_ALL:children]
staging_DB
staging_WEB
staging_APP

 и еще 
[prod_DB]
10.10.1.1

[prod_WEB]
10.10.2.2

[prod_APP]
10.10.3.3

[prod_ALL:children]
prod_DB
prod_WEB
prod_APP

[DB_ALL:children]
staging_DB
prod_DB

[APP_ALL:children]
ataging_APP
prod_APP

[RAZNOE:children]
APP_ALL
DB_ALL

а теперь создадим группу, которая объеденит параметры (не сервера)
(общие переменные группы),так делать рекомендовано, чтобы в группах
где сервера - были одни сервера, всё без лишних записей

[prod_servers:vars]
ansible_user=ec2-user
ansible_ssh_private_key_file=/home/ec2-user/.ssh/california-key2.pem

[RAZNOE:vars]
message=Hello

а вообше - хороший тон, чтобы в inventory были только сервера и/или 
только ip адреса, никаких переменных


чтобы посмотреть какие сервера прописаны и какие группы и переменные
есть нужно:  (но будет слишком развернуто)

ansible-inventory --list

и еще (покажет дерево)

ansible-inventory --graph



     Запуск Ad-Hoc Команд   (обычные команды ансибл, если они не в 
                             плэйбуке или файле)


перепишем наш hosts (уберем лишнее)

[stading_servers]
linuxX  ansible_host=172.31.8.69 ansible_user=ec2-user
   (продолдаем эту же строчку) ansible_ssh_private_key_file=/home/ec2-user/.ssh/california+key1.pem
                               

[prod_servers]
linux1  ansib_lehost=172.31.27.16
linux1  ansib_lehost=172.31.38.188

[prod_servers:vars]
ansible_user=ec2-user
ansible_ssh_private_key_file=/home/ec2-user/.ssh/california+key1.pem



Ad-Hoc Команды это:

ansible all -m ping

ansible all -m setup   --сканирует сервер и выдает о нем данные (адрес, какая ОС, время...)

ansible all -m shell -a "uptime"  --запустить шелл команды, -a -аргумент, т.е. команда 
                                    которая запуститься

ansible all -m command -a "uptime"  --запустить шелл команды, но не через шелл, поэтому
                                      переменные окружающей среды не будут видны ($home)
                                      и тут не будут работать перенаправления ">", 
                                      "<",  "|"


скопируем файл с мастреа ансибла на все сервера

создадим файл который будем копировать
echo "privet" > privet.txt

ansible all -m copy -a "src=privet.txt dest=/home mode=777"

src=privet.txt   --путь к копируемому файлу, т.к. файл в текущ директории,
                   то ничего не пишем, но можем и написать полный путь

dest=/home       --куда положим файл на удаленных хостах, тут лучше
                   указывать полный путь

mode=777         --сменим права при копировании (можно не указывать, тогда
                   права будут по умолчанию)


и можем получить ошибку  Destination /home not writable
потомучто команда запущена без sudo

переписываем и добавляем в конец -b (become) - чтобы получить права

ansible all -m copy -a "src=privet.txt dest=/home mode=777" -b

если мы еще раз запустим эту команду - то ничего не будет, т.к
файл уже существует (это точно такой же файл)


посмотрим, есть ли наш файл на удаленных серверах

ansible all -m shell -a "ls -la /home"

теперь файл удалим

ansible all -m file -a "path=/home/privrt.txt state=absent" -b

-m file    --может создавать файл, директории
лучше писать полный путь
 -b        --т.к. это удаление - даем sudo



скачиваем с сайта в интернете на все сервера

ansible all -m get_url -a "url=https://collection.com/rest/download/64 dest=/home" -b

url=https://collection.com/rest/download/64   --откуда брать файл (слеш не закрыт)
                                                обязательно указывать протокол (https)
dest=/home                                    --куда положить
-b                                            --судо


установка программ

ansible all -m yum -a "name=stress state=latest" -b
или
ansible all -m yum -a "name=stress state=installed" -b

-m yum             --потомучто у нас сейчас yum
name=stress        --название программы
state=latest       --последняя версия
state=installed    --тоже самое что и последняя версяи
-b                 --судо

удалить (деинсталлировать)

ansible all -m yum -a "name=stress state=removed" -b



читать с сайта информацию (проверка, можно ли подконнектиться 
к этому адресу с указанных серверов)

ansible all -m uri -a "url=http://www.adt-it.net"

получим статус "status": 200  ну или какой другой (200 - все ок)



если мы хотим посмотреть контент (получим код странички)

ansible all -m uri -a "url=http://www.adt-it.net return_content=yes"



установим веб сервер и запустим его (и чтобы был активен при перезагрузке)

ansible all -m yum -a "name=httpd state=latest" -b   --тут просто установка

ansible all -m service -a "name=httpd state=started enabled=yes -b   
--запуск и добавление в автозагрузку


дебаггинг

ansible all -m shell -a "ls /" -v
-v      --дебаггинг (verbose)
-vvvv   --еще больше информации


смотрим все модули которые есть в ансибл

ansible-doc -l

ansible-doc -l | grep win_     --можно фильтровать


Правила Формата YAML

все файлы yml начинаются с 
---

а вот заканчивать 
...
уже не обязательно

фармат - ключ - значение и списки

списки начинаются с пробел и минус
 -

важно - сколько пробелов (как правило они кратны 2), т.е.
пример списка

 fruits:
  - apple
  - orange
  - mango

если нужен еще список (список в списке), то уже ставим минус

 - fruits:
    - apple
    - orange
    - mango

 - vegetables:
    - carrots
    - cucumber

вот тут будет вложенный список (аттрибут с аттрибутами)

 - vasya:
    nick: vasek
    position: developer
    skills:
      - python
      - perl
      - php

 - petya:
     nick: pet
     position: manager
     skills:
       - manage
       - make_noise

 - petya:
     nick: "pettya: krutoy"

можно все писать в одну строчку
 - kolya: { nick: kolyan, position: administrator, skills: ['killer', 'cleaner'] }

внимание на скобки!
 fruits: ['apple', 'orange', 'mango']

ansible-inventory --list

 Перенос переменных в group_vars
чтобы не засорять инвентори - переменные выносим в отдельный файл
для начала создадим директорию


показать все серверы и какие переменные к ним относятся
mkdir group_vars


а в ней создаем файлы, которые называются как наши группы и внутрь
вставить строчки (переменные)

содержание инвентори

[STAGING_SERVERS_WEB:vars]
ansible_user=ec2-user
ansible_ssh_private_key_file=/home/ec2-user/.ssh/california-key1.pem

[PROD_SERVERS_WEB:vars]
ansible_user=ec2-user
ansible_ssh_private_key_file=/home/ec2-user/.ssh/california-key2.pem

[ALL_SERVERS_DB:vars]
db_endpoint=xxxxxx.yyyyyyyy.ocm:4151
owner=vasya
location="Hutson, TX"



переносим впеременные в файл - для этого создадим файл в group_vars
с именем сервера у которого будем выносить переменные
НО НЕМНОГО ИЗМЕНИМ СОДЕРЖАНИЕ
(двоеточие можно ставить где угодно, можно выравнить текст)
(вместо знака равно)

nano group_vars/STAGING_SERVERS_WEB
---
ansible_user                 : ec2-user
ansible_ssh_private_key_file : /home/ec2-user/.ssh/california-key1.pem

и ниже можно дописать все переменные которые относятся к нашей группе

а из хост-файла все стираем, включая название группы (в квадратных скобках)
вот это стираем
[STAGING_SERVERS_WEB:vars]
ansible_user=ec2-user
ansible_ssh_private_key_file=/home/ec2-user/.ssh/california-key1.pem



nano group_vars/ALL_SERVERS_DB
---
db_endpoint            : xxxxxx.yyyyyyyy.ocm:4151
owner                  : vasya
location               : "Hutson, TX"

не забываем удалить из инвентори\хостс



Первые Playbook

запускать:

ansible-playbook playbook1.yml

первый плэбук

---                                        --всегда в начале три минуса
- name: Trst Connection to my server       --имя, что делает плэйбук
  host: all                                --важен отступ - запуск на всех хостах
  become: yes  (true)                      --админские права, в нек случаеях писать true

  tesks:                                   --начинаем писать задачу
                                           --внимание на отступы!!!!
  - name: Ping my servers                  --имя команды
    ping:                                  --у пинга нет параметров



второй плэйбук

---
- name: Install default Apache Web Servers
  hosts: all
  become: all   (true)

  tasks:
  - name: Install Apache WebServer
    yum: name=httpd state=lstest         --мож быть apt - указать что устанавливаем
                                           и какую версию
    
  - name: Start Apache and Enable boot   --просто имя - запуск и прописать в автозагрузку
    service: name=httpd state=started enable=yes   (true)   --стартуем программу
                                                              и делаем ее автозагрузку


третий плэйбук

---
- name: Install Apache and upload my Web Page
  hosts: all
  become: all   (true)

  vars:
    source_file: ./MyWebSite/index.html    --файл который будем копировать
    destin_file: /var/www/html             --куда будем копировать файл

  tasks:
  - name: Install Apache Web Server
    yum: name=httpd state=latest

  - name: Copy MyHomePage to Servers
    copy: src={{ source_file }} dest={{ destin_file }} mode=0555  
                                           --переменные бурем из vars (чуть выше)
                                             права могуть быть 555 (без нуля)
    notyfy: Restart Apache                 --вызов хэндлера, его имя должно совпадать
                                           см ниже

  - name: Start WebServers and make it ensble on boot
    service: name=httpd state=started enable=yes (true)

но если мы обновим index.html то мы не получим ее без перезапуска сервера
всегда рестартовать нельзя
нужно сделать рестарт отлько после изменения index.html
для этого добавим хэндлерс (хендлерс)

  handlers:
  - name: Restart Apache
    service: name=httpd state=restarted




Переменные - Debug, Set_fact, Register

---
- name: My Super Playbook Variables Lesson
  hosts: all
  become: yes (true)

  vars:
    message1: Privet
    message2: World
    secret: wefwfewefwfw

  tasks:

  - name: Print Secret Variable
    debug:                  --необходимо для вывода на экран
      var: secret           --выводим сожержимое переменной secret

  - debug:
      msg: "Sekretnoe slovo: {{ secret }}"   --так же печатает вывод переменной

  - debug:
      msg: "Vladelec servera --> {{ owner }} <--"   --так же печатает вывод переменной
                                                    тут переменная лежит в hosts файле

  - set_fact: full_message="{{ message1 }} {{ message2 }} from {{ owner }}" 
                                                         --пишем название новой 
                                                           переменной соеденяем  
                                                           переменные, между ними пробел
                                                           чтобы был пробел. но вывода не будет
                                                           для вывода нужен debug

  - debug:
      var: full_message                                    --а тут уже выводит на экран


но у нас есть много переменных который энсибл собирает, но нам не показывает
ansible all -m setup     --так их можно посмотреть

отобразим сейчас значение одной из

  - debug:
      var: ansible_distribution                             --при использовании var
                                                            фигурные скобки не нужны
                                                            они нужны при использовании переменной

сохранение output команд

  -shell: uptime                         --тут команда выведется (выполнится) на сервер
                                         и ее вывод мы не увидим, чтобы увидеть, нужно
                                         вывод сохранить
   register: results                     --вот тут вывод сохранен в переменную results

  - debug:
      var: results                       --а тут уже выводим на экран


а чтобы печатать не все, а только строку продлеваем запись через точку

  - debug:
      var: results.stdout                 --выведет только строку относящ к stdout, но в нашем
                                          случае results содержала много строк, а мы тут взяли 
                                          только одну



 Блоки и Условия – Block-When

сейчас у нас 3 сервера, два - redhat и один Ubunru (debian)

используем плэйбук (немного его изменим)

---
- name: Install Apache and upload my Web Page
  hosts: all
  become: all   (true)

  vars:
    source_file: ./MyWebSite/index.html    --файл который будем копировать
    destin_file: /var/www/html             --куда будем копировать файл

  tasks:
  - name: Check and print LINUX version    --тут просто смотрим какие у нас linux
    debug: var=ansible_os_family

  tasks:
  - name: Install Apache Web Server for RedHat
    yum: name=httpd state=latest
    when: ansible_os_family == "RedHat"          --чтобы запустить этот таск только на
                                                 redhat (условие)

  tasks:
  - name: Install Apache Web Server for Debian   --тут устанавливаем для убунту (дебиан)
    apt: name=apache2 state=latest               но так нельзя - мы будем пытаться установить
                                                 везде этот пакет, а на 2 redhat - не получится
                                                 поэтому тоже пишем when
    when: ansible_os_family == "Debian"          --чтобы запустить этот таск только на Ubentu/Debian

    when: ansible_os_family != "RedHat"          --тоже самое, что и строка выше, но условие
                                                 "не равняется" - тут выполнится наsuse но
                                                 выдаст ошибку (ничего не сделает)
 

  - name: Copy MyHomePage to Servers
    copy: src={{ source_file }} dest={{ destin_file }} mode=0555  
                                           --переменные бурем из vars (чуть выше)
                                             права могуть быть 555 (без нуля)
#    notyfy: Restart Apache                 --вызов хэндлера, его имя должно совпадать
                                            см ниже, но тут пока закомментируем - все и
                                            без этой стр будет работать

  - name: Start WebServers for RedHat and make it ensble on boot
    service: name=httpd state=started enable=yes (true)
    when: ansible_os_family == "RedHat"

  - name: Start WebServers for Debian and make it ensble on boot
    service: name=apache2 state=started enable=yes (true)
    when: ansible_os_family == "Debian"

  handlers:
  - name: Restart Apache RedHat
    service: name=httpd state=restarted

  - name: Restart Apache Debian
    service: name=apache2 state=restarted


изменим наш плэйбук - перепишем все на блоки


---
- name: Install Apache and upload my Web Page
  hosts: all
  become: all   (true)

  vars:
    source_file: ./MyWebSite/index.html    --файл который будем копировать
    destin_file: /var/www/html             --куда будем копировать файл

  tasks:
  - name: Check and print LINUX version    --тут просто смотрим какие у нас linux
    debug: var=ansible_os_family
 
  - block:  #=== block for RedHat====


      - name: Install Apache Web Server for RedHat
        yum: name=httpd state=latest
   
      - name: Copy MyHomePage to Servers
        copy: src={{ source_file }} dest={{ destin_file }} mode=0555
        notyfi: Restart httpd

      - name: Start WebServers for RedHat and make it ensble on boot
        service: name=httpd state=started enable=yes (true)
    
    when: ansible_os_family == "RedHat"    --when должен быть под блоком!!


  - block:  #=== block for Ubuntu====

      - name: Install Apache Web Server for Debian   --тут устанавливаем для убунту (дебиан)
        apt: name=apache2 state=latest  

      - name: Copy MyHomePage to Servers
        copy: src={{ source_file }} dest={{ destin_file }} mode=0555
        notyfi: Restart Apache2

      - name: Start WebServers for Debian and make it ensble on boot
        service: name=apache2 state=started enable=yes (true)
    
    when: ansible_os_family == "Debian"

  handlers:
  - name: Restart Apache RedHat
    service: name=httpd state=restarted

  - name: Restart Apache Debian
    service: name=apache2 state=restarted




 Циклы – Loop, With_Items, Until, With_fileglob

---
- name: Loops Playbook
  hosts: linux3
  become3:   (true)

  tasks:
  - name: Say Hello to All           --привет всем владельцам
    debug: msg="Hello {{ item }}"    --item зарезервированное слово
    loop:                            --loop только в ансибл с 2,5, если 2,4
                                     там with_items
      - "Vasya"                      --перечисление для loop
      - "Petya"
      - "Masha"
      - "Olya"

другой вид loop - Until

  - name: Loop Until example
    shell: echo -n Z >> MyFile.txt && cat MyFile.txt  --сохраняем Z в файл и читаем его
    register: output                   --сохраняем результат в переменную
    delay: 2                           --задержка между запусками 2 сек
    retries: 10                        --повторить 10 раз, если не указать сколько - 
                                       по умолчанию всего 3 повтора
    until: output.stdout.find("ZZZZ") == false      --запускать команду shell, сохранять
                                                    что выведется на экран, 2 сек задержка,
                                                    все это повторять 10 раз. тут он проверяте
                                                    есть ли в нашем output ZZZZ (пока не наступило
                                                    ZZZZ) и повторяет это 10 раз
  - name: Prinu Final output
    debug:
      var: output.stdout             --напечатает то, что было в файле (наш stdout)

  - name: Install many packages
    yum: name={{ item }} state=installed
    loop:
      - python
      - tree
      - mysql-client


устанавливаем сервер, запуск и добавление в автозвгрузку, после
копируем папку, если копирование изменит метафайлы - будет 
сделат рестарт


---
- name: Install Apache and Upload my Home Page
  hosts: all
  become: yes (true)
 
  vars:
    source_folder: ./MyWebSite2
    destin_folder: ./var/www/html

  tasks:
    -block:   #=== For RedHat ===
       - name: Install Apache Web Server for RedHat
         yum: name=httpd state=latest

        - name: Start Web Server for Redhat
          service: name=httpd state=started enable=yes  (true)

       when: ansible_os_family == "RedHat"

    - block:  #=== For Ubuntu ===
 
      - name: Install Apache for Debian
        apt: name=apache2 state=latest

      - name: Start Web Server for Debian
        service: name=apache2 state=started enable=yes  (true)

      when: ansible_os_family == "Debian"



  - name: Copy HomePage file to Web Server
    copy: src={{ source_folder }}/{{ item }} dest={{ destin_folder }} mode=0555   --добавили item
    loop:                                     --список файлов которые внутри нашей папки
      - "index.html"                          --если файл скопируется - будет notify
      - "bahamas.png"
      - "bulgaria.png"
      - "jordan.png"
      - "newzeland.png"

другой способ копирования, без перечисления файлов
(делаем паттерн)
    copy: src={{ item }} dest={{ destin_folder }} mode=0555   --изменяем эту стр
    with_fileglob: "{{ source_folder }}/*.*"                  --указать полный путь (скопировать все)

    notify:                                   --вызываем всегда, для наглядности
      - Restart Apache RedHat
      - Restart Apache Debian




  handlers:
  - name: Restart Apache RedHat
    servce: name=httpd state=restarted
    when: ansible_os_family == "RedHat"     --добавляем условие!!

  - name: Restart Apache Debian
    servce: name=spsche2 state=restarted
    when: ansible_os_family == "Debian"     --добавляем условие!!



 Шаблоны - Jinja Template
расширение файла j2

например мы будем копировать файл, но чтоб файл был немного изменен
(генерация (копирование с изменением), другие переменные)

ансибл пройдется по j2 (шаблону) и все заменит для текущ хоста - подставит
значение в переменные, а если не найдет значений - напишит ошибку

наш текущ hosts содержит:

[ALL_LINUX]
linux1  ansible_host=172.31.3.113   owner=Petya
linux3  ansible_host=172.31.19.251  owner=Vasya

теперь идем в нашу директорию и переименовываем
index.html в index.j2
но это как бы остался наш thml файл, но мы его немного изменим

добавим туда строки
(для крастоты изменим цвет)
<font color="gold">Owner of this server is: {{ owner }}<br>   --добавили переменную с владельцем
                                                              она подставит туда владельца
Server Host Name : {{ ansible_hostname}}<br>                  --добавили переменную с именем хоста
Server OS Family : {{ ansible_os_family}}<br>                 --добавили переменную с OS
IP Address of this Server is : {{ ansible_default_ipv4.address }}<br>


в самом yml файле команда будет уже не копировать, пример:

- nane: Generate INDEX.HTML file
  template: src={{ source_folder }}/index.j2 dest={{ destin_folder }}/index.html mode=0555
                                --вот этот модуль и генерирует, очень похож на копирование
                                не забыть в назначении указать "нужный", а не шаблонный файл
                                т.е. как он будет называться после отработки анибла
  notyfy:                       --вывод успех или нет
    - Restart Apache RedHat     --перезапуск сервисов
    - Restart ApacheDebiad



Создание Ролей - Roles

нужно создать директорию roles

чтобы создать роль depalay_apache_web
в директории

ansible-galaxy init depalay_apache_web

эта команда создаст директорю depalay_apache_web в которой будут лежать
файлы и директории, все файлы будут пустые

не забыть выставлять пробелы (форматировать)

идем в документацию по ролям и видим, что там рекомендовано
в tasks - положить наши таски, слово tasks уже писать не нужно
          (начинаеться с block или name)
в handlers - положить наши хэндлеры, но само слово handlers
             нам уже не нужно
в default - положить default переменные для этой роли
в vars - другие переменные для этой роли (разница директорий не понятна), само
         слово vars не нужно
в files - файлы которые д.б. копированы - т.е. все картинки которые мы копируем
          положим сюда
в templates - файлы которые д.б. генерированы - j2 файлы например
в meta - хз

теперь наш обычный рлэйбук нужно распилить на части и положить в 
эти директории

в файле tasks - нужно будет переписать пути источника и достижения

в самом файле playbook6.yml

---
- name: Install Apache anu Uppload my Home Pages
  hosts: all
  become: yes   (true)

и теперь тут пишим роли

  roles:
    - deploy_apache_web
    - deploy_db
    - configure_xxxxxxxx


а чтобы роль запускать (с условием) только на серверах linux
  roles:
    - { role: deploy_apache_web, when: ansyble_system == 'Linux'}


запуск этого всего:

ansible-playbook playtbook.yml



 Внешние переменные - extra-vars

у нас есть наш плэйбук
---
- name: Install Apache
  hosts: all
  become: yes


чтобы каждый раз не редактировать файл, а использовать переменные нужно
изменить, на примере hosts

  hosts: "{{ MYHOSTS }}"

вот так выглядит внешняя переменная

чтобы запустить

ansible-playbook playbook6.yml --extra-vars "MYHOSTS=STAGING"

допускается писать
--extra-var
--e
 
тут STAGING  - группа определенная в файле hosts
т.е. сейчас запустится плэйбук только для серверов состоящ в группе STAGING

например сделаем
ansible-playbook playbook6.yml --extra-vars "MYHOSTS=STAGING owner=DENIS"

и переменная которая определена в файле hosts - перепишется, т.к экстара варс
(внешняя переменная) имеет приоритет наивысший приоритет, т.е. они заменяют
все значения


если запустить плэйбук без переменной, а плэйбук ее ожидает - будет ошибка
(undefined)



 Использование Import, Include

используем для разделения (декомпозиции)

создаем файлик который будет создавать только директории
(их модет быть тут много, но у нас две директории)

nano create_folder.yml

его содержание

---
- name: Create folder 1
  file:
    path: /home/secret/folder1
    state: directory
    mode: 0755

 - name: Create folder 2
   file:
     path: /home/secret/folder2
     state: directory
     mode: 0755


теперь создаем файлы

nano create_files.yml

---
 - name: Create file1
   copy:
      dest: /home/secret/file1.txt
      content:
        Text Line1, in file1      --эта строка так и запишется в файл
        Text Line2, in file1
        Text Line3, {{ mytext }}

 - name: Create file2
   copy:
      dest: /home/secret/file2.txt
      content:
        Text Line1, in file2
        Text Line2, in file2
        Text Line3, {{ mytext }}


а теперь наш главный плэйбук будет включать наши файлики по созданию 
директорий и файлов

playbook7.includes.yml
---
 - name: My Super Playbook
   hosts: all
   become: yes   (true)

   vars:
    mytex: "Privet ot ADV-IT"

   tasks:
   - name: Ping test
     ping:

теперь включаем наши файлы

 - name: Create Folders
   include_tasks:     --используем include, через подчеркивание можем 
                      дописывать все, что угодно или просто include
                      на этом и остановимся

    include: create_folders.yml   --название нашего файла
    import: create_folders.yml    --название нашего файла - тоже работает

 - name: Create Files
    include: create_files.yml   --название нашего файла


отличие  Import от Include

если делать import - ансибл пройдется по всему плэйбуку перед тем как запустить
задачи (как бы делает парсинг и проверяет синтаксис)
берет import и сразу же все "копирует во внутрь главного плэйбука"
и подставляет значение переменных, в нашем случае {{ mytext }}
т.е. делает все и сразу как запустился


include - подставляется только тогда, когда ансибл доходит до этой строки 
и подстановка переменных осущестл только тогда, когда ансиб дошел до
этой строки


так же можно "перекидывать" переменные

  include: create_files.yml  mytext="Hrllo world"   --вот так подменили переменную




Перенаправление выполнения Task из Playbook на определённый сервер - delegate_to
(Как запускать таски не на всех серверах, а на одном определенном сервере)


---
 - name: My Super Playbook
   hosts: all
   become: yes   (true)

   vars:
    mytex: "Privet ot ADV-IT"

   tasks:
   - name: Ping test
     ping:

 - name: Create file1
   copy:
      dest: /home/secret/file1.txt
      content:
        Text Line1, in file1      --эта строка так и запишется в файл
        Text Line2, in file1
        Text Line3, {{ mytext }}
   delegate_to: linux3           --теперь эта таска выполнится только 
                                 на linux3 сервере. т.е. файл создастся
                                 только на сервере linux3, но побежиться
                                 эта таска и на другом, но на другом не
                                 создаст файл


 - name: Create file2
   copy:
      dest: /home/secret/file2.txt
      content:
        Text Line1, in file2
        Text Line2, in file2
        Text Line3, {{ mytext }}

для чего и зачем - ну например чтобы убрать решистрацию
(вставим строчку до задачь по созданию файлов)

- name: Unregister server from Load Balancer
  shell: echo This server {{ inventory_hostname }} was 
       deregister from Load Balanser >> /home/log.txt
    --вот чтобы не на всех серверах запустилась таска - 
    делегируем ее только на наш (нам так надо)
  delegate_to: 127.0.0.1           --вот эта строчка
                 --тут у нас запустится таска
                  и в наш locathost запишутся переменные
                  из других серверов


а сейчас перезапустим сервера и подождем пока они поднимаутся

- name: Reboot my servers
  shell: sleep 3 && reboot now
  async: 1   --просто так надо, чтоб небыло ошибок
  poll: 0    --закринуть команду на сервер и ничего не ждать, 
             просто отключитьсяо от него (проверять статус -
             закончилась ли команда)

 - name: Wait till my server will come up
   wait_for:                             --ждем (чего?) 
     host: "{{ inventory_hostname }}"    --ждем именно наш хост
     state: started                      --ждем чтобы был запущен
     delay: 5                            --начинать считать с 5 сек после как 
                                         прошла команда
     timeout: 40                         --сколько max ждать времени (в секундах)
     geligate_to: 127.0.0.1

так можно "оставить след" на местере


а сейчас нам нужно обновить базу данных (пойдет по порядку
который первый в интветори), но только один раз
и не важно с каких серверов это бы происходило
(еденичное выполнение)

- name: Updating my Database
  shell: echo UPDATING Database
  run_once: true

ну тут можно еще добавить deligate_to и указать на каком
а если не добавлять, будет, вероятно всего, на первом 
из списка в инвентори


Перехват и Контроль ошибок

например у нас есть 3 хоста, мы запускаем плэйбук и на одном (пусть втором)
таск завершилась с ошибкой, на третьем все ок, дальше 1 - ок, а вот второй
уже не запустит следующие таски, он как будто выйдет из игры
как же контролировать?

nano playbook_errorhandling.yml

---
- name: Ansible lesson 19
  host: all
  become: yes   (true)

  tasks:
  - name: Task Number1
    yum: name=treeeee state=latest     --допущена ошибка в имени пакета и из-за
                                       ошибки следующ таски не будут выполнены
    ignore_errors: yes                 --если бодавить, то ошибки игнорируются и
                                       плэйбук выполняется дальше, а не завершается 
                                       с ошибкой
  
  - name: Task Number2
    shell: ls -la /etc/
    register: results                  --будет ли продолжено выполнение и вообще продолжнено 
                                       ли оно, сохраним выполнение в переменной в result 

  - debug:
      var: results                     --выводим перемен на экран

  - name: Task Number3
    shell: echo PrivetMir!


обрабатываем - если у нас есть что то в выводе то мы хотим это посчитать ошибкой
или наоборот принять как истину

  - name: Task Number4
    shell: echo Hello World!
    register: results
    failed_when: "'World' in results.stdout"    --это как бы фильтр - ищет в тексте
                                                точнее в переменной results, которая
                                                отдает stdout - вот в нем и ищем
                                                и если найдем World - сделаем failed

но т.к. мы не указали после ignore_errors - ниже таски выполнять не будут

еще контроль делают по return code , т.е. по rc=0, если =0 то
команда выполнена удачно

  - name: Task Number5
    shell: echo Hello World!
    register: results
    failed_when: results.rc == 0
или
    failed_when: results.rc != 0

а теперь сделаем чтобы у нас прекращалось выполнение не на одном сервере а на всех
при возникновении ошибки хоть на каком то сервере
сделать фатальную ошибку

в этом случае нужно добавлять сверху

---
- name: Ansible lesson 19
  host: all
  any_errors_fatal: true      --вот тут это объявляется
  become: yes   (true)




 Хранение Секретов - ansible-vault

ansible-vault create










