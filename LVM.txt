LVM

https://www.youtube.com/watch?v=awK1LT2oPXM
https://www.youtube.com/watch?v=3LJILXKf9XY

https://www.youtube.com/watch?v=tLQ2PtSVr58

посмотреть жесткий диск
ls -l /dev/sd*

чтообы посмотреть все диски которые существуют
смотрим диск по id  - увидим ссылки на физические устройства
ls -l /dev/disk/by-id

смотрим диск по меткам (label)
ls -l /dev/disk/by-label

будем готовить диск sda (новый, не задействованный)
укажем, что будем работать именно с диском sda
parted /dev/sda

создаем метку диска (partition table) - тип msdos (до 2 тб физич размера) (если  физический диск больше 2 тб - использовать gpt)
но разделы еще не создаем, создали только тип!
mklabel msdos (mbr)

теперь смотрим, "из чего состоит жесткий диск" - покажет модель, объем, сектора...
p   (print)

q  --quit - выйдем из parted

сейчас получили жесткий диск без разделов, но с partition table (подготовили диск)

СОЗДАЕМ  LVM  СТРУКТУРУ:
1. пометим то устройство, которое должно войти в lvm структуру (весь диск) (phisical volume create)
pvcreate /dev/sda

(если нужно добавить какой то раздел на диске, то pvcreate /dev/sda1)

чтобы удалить диск из lvm
pvremove /dev/sda

2. создаем volume pool - это некая группа, в которую будут входить наши физические диски (или разделы) (volume group create)
vgcreate vg0 /dev/sda
vg0   --- имя группы - нужно коротко и ясно, тут для первого диска создали vg0 - "volume group 0"
/dev/sda  --- наш подготовленный диск


посмотреть информацию о группах
vgdisplay   --- покажет всю инф по всем группам
VG NAME - ИМЯ ГРУПП
FORMAT - хз
VG ACCESS - СТАТУС ЧТЕНИЯ/ЗАПИСИ
VG STATUS - ИЗМЕНЯЕМАЯ В РАЗМЕРАХ
MAX LV - LV = LOGICAL VOLUME
CURR LV - ТЕКУЩ ЛОГИЧЕСКИЕ ТОМА (СКОЛЬКО ВСЕГО) В ЭТОЙ ГРУППЕ (СКОЛЬКО РАЗДЕЛОВ СОДЕРЖИТ ГРУППА)
OPEN LV
MAX PV  - PV = PHISICAL VOLUME
CUR PV - ТЕКУЩЕЕ УСТРОЙСТВО
ACT PV - ВСЕГО УСТРОЙСТВ? - НЕ ТОЧНО
VG SIZE - VOLUME GROUP SIZE - РАЗМЕР ДОСТУПНОГО МЕСТА? - при добавлении еще одного диска - размер вырастет
PE SIZE - PHISICAL EXTEND - БЛОКИ, КОТОРЫЕ ОБРАБАТЫВАЕТ LOGICAL VOLUME, Т.Е. ЗАПИСЫВАЕТ И СЧИТЫВАЕТ ИНФОРМАЦИЮ БЛОЧНО
TOTAL PE - ВСЕГО PHISICAL EXTEND - ПЕРЕМНОЖИВ PE SIZE И TOTAL PE = ПОЛУЧИМ РАЗМЕР ДОСТУПНОГО МЕСТА
ALLOC PE - ALLOCATE PHISICAL EXTENTION (SIZE) - СКОЛЬКО РАСПРЕДЕЛЕНО
FREE PE - FREE PHISICAL EXTENTION (SIZE) - СВОБОДНОГО
VG UUID  - УНИКАЛЬНЫЙ ИДЕНТИФИКАТОР

pvdisplay  - (phisical volume) смотреть какие, на данный момент времени, существуют устройства, которые ранее были помечены как phisical vilume
PV NAME - ИМЯ ФИЗИЧЕСКОГО УСТРОЙСТВА
VG NAME - КУДА ЭТОТ ДИСК (УСТРОЙСТВО) ВХОДИТ - В КАКУЮ ГРУППУ
PV SIZE - РАЗМЕР ЭТОГО УСТРОЙСТВА
ALLOCATED PE / SIZE - СКОЛЬКО РАСПРЕДЕЛЕНО (СКОЛЬКО ИСПОЛЬЗУЕМ)
FREE PE / SIZE  - СКОЛЬКО ОСТАЛОСЬ СВОБОДНОГО МЕСТА НА ЭТОМ РАЗДЕЛЕ (ЕЩЕ НЕ РАСПРЕДЕЛЕНО)


3. создаем логические разделы нашего пула (который называется vg0)
lvcreate (logical volume create)

lvcreate -n swap -L1G vg0
-n -- осмысленное наименование этого раздела (имя/метка), как будем его использовать, например swap
-L1G -- размер, сейчас 1 гб (внимание на большие буквы) (-L1MB размер в мб)
vg0  -- в какой volume group мы выделяем этот размер


lvdisplay (logical volume) - смотреть что получилось на последнем этапе
LV PATH - ПОЛНЫЙ ПУТЬ ДО ЭТОГО РАЗДЕЛА (ССЫЛКА НА НЕГО)
LV NAME - НАШЕ ИМЯ
VG NAME - В КАКУЮ ГРУППУ ВХОДИТ НАШ ЛОГИЧЕСКИЙ РАЗДЕЛ
LV WRITE ACCESS - (LOGICAL VOLUME) - ЧТЕНИЕ / ЗАПИСЬ
LV STATUS - ДОСТУПНО
LV SIZE - НАШ РЕЗМЕР
CURRENT LE  - КОЛ-ВО LOGICAL EXTENT

3.1. СОЗДАЕМ ЕЩЕ ОДИН РАЗДЕЛ НА ЭТОМ VOLUME В ЭТОЙ ГРУППЕ
lvcreate -n root -l100%FREE vg0
-l100%FREE -- l (Л маленькая!) 100%FREE - ВСЕ ДОСТУПНОЕ МЕСТО (РАЗМЕР ДО КОНЦА РАЗДЕЛА)


РАЗРУШАЕМ ЛОГИЧЕСКИЕ ТОМА - нужно идти в обратном порядке
1. удаляем все логические тома
lvremove /dev/vg0/root  --путь до нашиих логических томов. не имеет значения какой первый раздел (имя) 
(swap или root в нашем случае) будем указывать, но то, что нужно начинать с logical volume remove- это 
обязательно - если разрушать все - то и удаляем все созданные разделы

lvremove /dev/vg0/root
lvremove /dev/vg0/swap

теперь нам lvdisplay ничего не покажет

2. теперь разрушаем (удаляем) группы
vgremove vg0  --vg0  это какую группу мы хотим удалить

3. удаление (разрушение) нашего "устройства" на котором базировалась наша группа
pvremove /dev/sda  - /dev/sda какие устройства должны быть очищены от метки phisical volume


удаялем раздел(ы)

parted
p - смотрим разделы
rm 1  -- удалим первый раздел - диск будет не размеченный

--- сейчас попробуем создать lvm с разделом gpt (если диск более 2 тб)-----

отличее от создание msdos раздела - для gpt нужно иметь хотя бы один раздел обязательно, который мы будем использвать под phisical volume!

parted /dev/sda

mklabel gpt 

mkpart 

mkpart -- создаем раздел, программа попросит ввести еще данные:
Partition name  -- имя раздела - так же кратко и понятно, например сейчас lvm
File system type  -- тип файловой системы - ext4 например
Start 1   -- стартовое значение - с ПЕРВОГО мегабайта (самое начало)
End -1   -- конечное значение (минус 1) - по самый конец диска 

q  --quit - выйдем из parted

ls -l /dev/sd*  -- посмотрим, что есть из дисков (разделов) теперь - у нас появился sda1 , это раздел, на котором будем создавать наш lvm, а сам физический диск /dev/sda - трогать уже не будем

pvcreate /dev/sda1
остальное одиноково
vgcreate vg0 /dev/sda1
lvcreate -n swap -L1G vg0


--- подготавливаем дикс для установки операционной системы ----
для этого нужно выбрать, какой вариант partition table будем использовать
Если будем использовать gpt - разметим его немного по другому

parted /dev/sda

для gpt в самом начале диска должен быть раздел, нужный для загрузки операционной системы
прежде чем его создать - вводим еденицы измерения

unit mib   -- наи ед измерения - мегабайты - которые 2 в степени ...(мы находимся в parted)

теперь создаем первый раздел

mkpart
Partition name []? biosgrub    -- biosgrub название нашего первого раздела
File system type? [ext2]  -- оставили по умолчанию
Start? 1   -- старотовое значение - с первого мегабайта
End? 65    -- конечное значение, всего хотим чтобы размер был 64 мб +1 мб от старта, итого и получаем 65  (если бы мы
 написали 64, то размер бы создался 63 мб)

чтобы система понимала, что это специальный раздел для загрузки, нам нужно
set 1 bios_grub on   --установить на первый раздел флаг bios_grub и его включить.   система сама все определит и положит туда 
файлы. для gpt файлы загрузчика grub болжны находиться на своем физическом разделе, в логическом (lvm) нельзя!

создаем еще один физический раздел
mkpart
Partition name []? boot -- boot название нашего второго раздела (там будет точка монтирования boot)
File system type? [ext2]  -- оставили по умолчанию
Start? 65   -- старотовое значение - такое же, как и конечное прошлого раздела
End? 321    -- выделяем 256мб  65+256=321  можно выделять до 1 Гб, больше не стоит
вот в этом (втором) физическом разделе boot будут находиться файлы grub, init.ram, ядро и это ядро сможет подключить vlm том и передать загрузку дальше

создаем еще один раздел, lvm
mkpart
Partition name []? lvm    -- lvm название нашего третьего раздела
File system type? [ext2]  -- оставили по умолчанию
Start? 321   -- старотовое значение - с первого мегабайта
End? -1    -- создаем по самый конец раздела


вот такая минимально филическая разметка должна быть при gpt разметки для установки операционной системы

а для mbr (msdos) можно не делать первый раздел, оставить только второй и третий, размер boot оставить таким же

q   -- выходим из parted

обратить внимание какой раздел сейчас указывать для создания lvm! у нас их сейчас три  - при gpt используем /dev/sda3   (в случае 
msdos третьего раздела не будет)

pvcreate /dev/sda3

vgcreate vg0 /dev/sda3   -- vg0 имя группы, sda3 - наш раздел, который мы включили в lvm

lvcreate -n root -L6G vg0   -- раздел с именем root, размером 6ги именем группы vg0

lvcreate -n swap -L1G vg0   -- раздел для swap, чтобы наша операционная система работала нормально (ставим линукс)

(volume group всегда делать с запасом, т.к. увеличить легко, а вот уменьшить том очень сложно  ,   т.е. делать сколько нужно + запас)

создаем файловую систему - 2 варианта - самим или при запуске установки операц системы - создать уже силми установщика ОС

создадим руками

mkfs.ext4  /dev/vg0/root    -- нельзя указывать физический том, нужно указывать ЛОГИЧЕСКИЙ!  сейчас мы работаем только с логическими томами

а теперь сожно и установливать linux - но при установке нужно распределить диск - выбираем "другой вариант" - смотрим инф, которая начинается 
с  /dev/sda - свободное место 1 мб - пропускаем, /dev/sda1 (biosgrub) - установщик должен его определить сам и его тоже трогать не нужно, 
сл раздел - /dev/sda2 - мы делали, чтобы там распологались все оставшиеся файлы загрущика (grub) - его выбираем, жмем "изменить" - использовать 
как - файловая система ext4, при первом использовании раздел можно не форматировать, а при повторной установке - фарматировать 
придется и указать точку монтрования boot
сл раздел /dev/sda3 - трогать так жде нельзя - т.к. он отдан под lvm
все, что мы должны были тут сделать - это задать разделу boot и указать файловую систему
теперь вернемся в самое начало, где указано /dev/mapper/vg0/root - его так же обязательно выбираем, жмем "изменить" указываем файловую систему 
ext4, форматировать не обязательно, т.к. первая установка, точка монтирования - root и таким же образом укажем всё для раздела swap
жмем "установить сейчас", будет предупреждение, что раздел не форматирован и некоторые файлы будут сохраненыв - жмем утрвердительно, тюкю у еас 
ничего нет - первая установка

а зачем всё это?
в одну группу (vg0) (путь и созданной на рэйд массивах или просто) мы устанавливаем операционную систему
а вторую группу (vg1) - мы складываем бэкапы из vg0

правило - одна волиум групп - одна задача


   УВЕЛИЧИВАЕМ РАЗМЕР РАЗДЕЛА
vgdisplay - смотрим сколько свободного места в нашей группе
FREE PE / SIZE  -  700 мб   свободно

ПОМНИТЬ - ВСЕГДА ДОЛЖЕН БЫТЬ ЗАПАС СВОБОДНОГО ВРЕМИЕНИ У ЛОГИЧЕСКОГО ТОМА

lvextend  -  увеличивает объем тома
lvextend -L32G - точное конечное значение тома - тут 32 гиг
или
lvextend -L+512Mb - тут сколько прибавляем (на сколько увелдичиваем) - на 512 мб

lvextend -L+512Mb /dev/vg0/root   --тут указываем какой том увеличиваем

но это еще не все, тут мы увеличили НЕ размер файловой системы, на которое можно что то записывать, мы просто прибавили к группе объем

вот сейчас увеличим размер файловой системы
resize2fs /dev/vg0/root   --указываем то место, к которому прибавили и которое нужно изменить (применить увеличение объема)



lvextend -r   -- позволяет автоматически подстроить размер файловой системы под контейнер  - автоматически подстроит прибавленный размер к файловой 
системе  - автоматически запустит resize2fs

lvextend -r -L+128Mb /dev/vg0/root



  ЧТОБЫ УМЕНЬШИТЬ РАЗМЕР ГРУППЫ
сначала уменьшаем размер файловой системы, а потом уменьшаем объем диска - обратный порядок увеличения

НЕ ЗАБЫТЬ ОТМОНТИРОВАТЬ РАРЗДЕЛ!
но не все разделы можно отмонтировать - поэтому грузимся с live-cd

смотрим, распознала ли наша live-cd наш LVM
vgdisplay  --покажет нам и группы и логические разделы
VG NAME - vg0
CUR VG - 2
OPEN LV - 0

можем еще посмотреть логические тома
lvdisplay   --покажет наши логические разделы

для начала уменьшаем файловую систему - если объем записи не занимает все 100% или не занимает больше, чем мы хотим уменьшить

не плохо было бы ПРОВЕРИТЬ ФАЙЛОВУЮ СИСТЕМУ НА ОШИБКИ
e2fsck /dev/vg0/root
 
e2fsck -f /dev/vg0/root   -- -f  более детальная проверка

а сейчас уменьшаем

lvreduce -r -L-512MB /dev/vg0/root   -- -r автоматическая подстройка и применение изменений, -L-512MB - ументшаем на 512мб,  /dev/vg0/root - какой 
раздел уменьшаем  - должен быть отмонтирован


ПОДКЛЮЧАЕМ НОВЫЙ ДИСК И ДОБАВЛЯЕМ ЕГО В LVM
ls -l /dev/sd*    --смотрим, какие диски у нас есть
/dev/sdb  - y нас появился, его и будем добавлять

подготавливаем
parted /dev/sdb

тут так же 2 варианта - разметка или msdos (mbr)  или gpt
возможно совместить 2 типа - т.е. первый будет gpt, а второй mbr

mklabel msdos   -- создадим msdos

parted /dev/sdb  -- зашли в утилиту
p   -- просмотр информации о диске (разделах) - тут будет указана какая таблица разделов уже есть на этом диске

pvcreate /dev/sdb   --помечаем диск под lvm и вксь объем отдаем его lvm

поскольку мы подключаем (добавляем) диск к старой  группе - новыю не создаем на этом диске

vgextend vg0 /dev/sdb   --указываем какую группу изменяем и какие устройства должны в нее войти

теперь смотрим
vgdisplay  --ПОКАЖЕТ, ЧТО У НАС 2 УСТРОЙСТВА
MAX PV  - 0
CUR PV  - 2
ACT PV  - 2
FREE PE / SIZE  - 8.55GiB -- УВЕЛИЧИЛСЯ ОБЪЕМ

lvextend -r -L12G /dv/vg0/root  -- увеличиваем наш раздел до 12Гб  (а не на 12г)



ДЕЛАЕМ НОВЫЙ ЛОГИЧЕСКИЙ РАЗДЕЛ В ГРУППЕ vg0

lvcreate -n home -L2G vg0  -- новый, название home, размер 2Г, группа vg0 которая уже существует

vgdisplay /dev/vg0/home   --инф по этому (home) разделу в группе vg0

mkfs.ext4 /dev/vg0/home   -- создали в home файловую систему ext4

mkdir /mnt/hpme   --создали папку, куда будем монтировать наш новый раздел
mount /dev/vg0/home /mnt/home   --монтируем
rsync -avXP /home/. /mnt/home/.  -- перемещаем все данные из старого тома, в наш новый примонтированный том  - создали полную копию на /mnt/home/

после нужно настроить автомантирование в fstab
nano /etc/fstab   --открываем файл на редактирование, где пропишем наш новый том, чтобы монтировался втоматически

по аналогии пишем
/dev/mapper/vg0-home   /home     ext4    default   0  2

так тоже можно
/dev/vg0/home     /home     ext4    default   0  2

(но посмотри в систему бэкапа - там через UUID)


   ДЕЛАЕМ  BACKUP  СРЕДСТВАМИ  SNAPSHOT
чтобы создать бэкап - нужно, чтобы данные во время бэкапа не изменялись
снэпшот - некий снимок, который был на время создания снэпшота
для этого нам нужно некоторое место на бэкапируемом диске


ЕЩЁ РАЗ ДОБАВИМ ДИСК (ДРУГОЙ)
(2 диска добавили sdc(msdos) и sdd->sdd1(gpt) и создали раздел)

для добавления в группу, перед добавлением, необходимо пометить физическое устройство как lvm
pvcrate /dev/sdc/

теперь вводим в lvm
vgextend vg0 (в какую группу) /dev/dsc (какие диски если несколько - указываем через пробел)

создадим еще один lvm - для sdd, но уже в другой группе
pvcreate /dev/sdd1
vgcreate vg1 /dev/sdd1
создаем раздел
lvcreate -n backup (осмысленное название) -l100%FREE (весь объем диска) vg1 (отдельная, новая группа, которую создалил на отдельном 
диске специально для бэкапа)
теперь создаем там файловую систему
mkfs.ext4 /dev/vg1/backup (внимательнее!)


а теперь приготавливаем все для бэкапа
mkdir /mnt/backup
mount /dev/vg1/backup /mnt/backup

создаем снэпшот
lvcreate -s -n home_snap -L128M /dev/vg0/home
-s  --создает снэпшот, а не логический раздел
-n  --на какой lvm том создается этот снэпшот
home_snap  --имя этого тома, но это уже сам снэпшот, для понятности дописываем, чтобы по наименованию мы его легко определили
-L128M  --это уже размер буфера, на который будут записываться все изменения с реальной файловой системы, за период существования 
этого снэпшота - это НЕ размер снэпшота, а размер буфера! для этого снэпшота
/dev/vg0/home  --путь к нашему lvm тому на который мы хотим создать снэпшот

если мы посмотрим
vgdisplay vg0
то увидим, что FREE PE / SIZE у нас изменился - уменьшился на размер указанного нами буфера
если теперь посмотреть конкретно по томам
vldisplay /dev/vg0/home*
мы увидим, что у нас сейчас 2 логических тома - home и home_snap
на  home появилась надпись
LV SNAPSHOT STATUS   --SOURCE OF HOME_SNAP [ACTIVE]  --является источником для home_snap (с него будут забирать туда - на home_snap) и он активен

а на разделе home_snap появилась своя запись
LV SNAPSHOT STATUS   --ACTIVE DESTINATION FOR HOME --является активным и его источник раздел home
LV SIZE   --2.0 GIB   --показывает размер 2 гиг, равный разделу home, хотя мы создавали буфер в 128м
COW-TABLE SIZE  --128MIB   -- вот она, наша область (выделенный размер)
COW-TABLE LE    --32  --logical extendet = 32 штуки
ALLOCATED TO SNAPSHOT  --0.08%   --сколько уже занято места в буфере

ЧТО ТАКОЕ ЭТОТ БУФЕР - это область с таким размером, на которую будет происходить запись во время бэкапа, а потом, когда бэкап кончится, из 
этого буфера все запишится в обычый раздел. размер должен быть ьдостаточным, чтобы уместились все изменения - нужно рассчитывать

как это выглядет:
сейчас мы в home запишем файл 32мб (33,55мб)
параметры в томе home не поменялись (размер)
но ищменились параметры в home_snap
ALLOCATED TO SNAPSHOT  --25.21%  стал сейчас
эта запись нам говорит, что в разделе home были изменения и эти изменения 25,21% от 128мб нашего буфера
т.е. при записи/удалении - информация об этом записывается в ALLOCATED TO SNAPSHOT который относится к текущему снэпшоту

чтобы ПОСМОТРЕТЬ, ЧТО НАХОДИТСЯ В СНЭПШОТЕ
примонтируем его в отдельный каталог
mkdir /mnt/home_snap
mount /dev/vg0/home_snap /mnt/home_snap
ls -l /mnt/home_snap
и мы увидим, что в этом снэпшоте находятся файлы, на момент создания снэпшота
т.е. созданный нами файл в снэпшот не попал
и оттуда (из /mnt/home_snap) мы можем теперь делать бэкапы не боясь, что данные изменились, а после копирования - мы удаляем снэпшот. 
на реальном разделе ничего не удалится и вообще никак не отобразится

А ЧТО, ЕСЛИ МЫ ПЕРЕПОЛНИМ БУФЕР?
снэпшот содержит именно изменения (записи об изменениях) в файловой системе целевого устройства - сколько %% изменилось.
сейчас мф наш созданный файл удалим и опять посмотрим на 
lvdisplay /dev/vg0/home_snap
и мы увидим, что 
ALLOCATED TO SNAPSHOT  --25.28%  стал сейчас -т.е. информация изменилась совсем мало (было 25.21%) и информация об 
изменении не вернулась в первоначальное значение (почти 0)
- в область снэпшота записывается все с начала его существования по его конец

--перепоняем буфер
создадим файл объемом 256мб
сейчас в основном томе
LV SNAPSHOT STATUS   --INACTIVE
и в снапшоте
LV SNAPSHOT STATUS   --INACTIVE
и все вернулось на первоначальное значение
COW-TABLE SIZE  --128MIB
COW-TABLE LE    --32
т.е. сейчас нет гарантий, что в томе снэпшота отображается действительная информация о реальном томе  -- переполнение буфера - ошибка
буфер нужно просчитывать 

УДАЛЯЕМ СНЭПШОТ
для начала его нужно отмонтировать
umount /mnt/home_snap
lvremove /dev/vg0/home_snap  --внимательнее!
при переполнении, при попытке удалить будет ошибка, о том, что снэпшот не является целостным - не отображает действительность (у нас же переполнение)
но мы соглашаемся с уничтодением всеравно
при уладении снэпшота, основной том не затрагивается

Т.Е. СНЭПШОТ КОТОРЫЙ БОЛЕЕ НЕ НУЖЕН - УДАЛЯТЬ

НЕДОСТАТКИ СНЭПШОТА
1. нужно просчитывать объем буфера
2. скорость записис на том , после создания снэпшота, резко снижается


СНЭПШОТ МОЖНО ДЕЛАТЬ ТОЛЬКО НА ЧТЕНИЕ
lvcreate -s -p r -n home_snap -L1G /dev/vg0/home
-p r --только на чтение
-p rw -- чтение/запись - на чтение/запись этот параметр можно не указывать

lvdisplay /dev/vg0/home_snap
LV WRITE ACCESS  --READ ONLY
если такой "снэпшот" мы примонтируем и попытаемся туда что то записать - у нас ничего не получится
это нужно только для создания бэкапов - когда мы только читаем данные


КОГДА МЫ НЕПОСРЕДСТВЕННО ЗАПИСЫВАЕМ ФАЙЛ В "СНЭПШОТ", ТО МЫ ИСПОЛЬЗУЕМ ТЕ ЖЕ ТАБЛИЦЫ (БУФЕР БУДЕТ УМЕЬШАТЬСЯ)

ЗАЧЕМ ПИСАТЬ В СНЭПШОТ - ПОКА НЕ ЗНАЮ


ЕСЛИ ОДИН ИЗ ДИСКОВ ВЫХОДИТ ИЗ СТРОЯ
сейчас у нас в группе vg0  - 3ри физических диска
неисправный мы хотим вытащить, но это нужно сделать корректно.
где какие файлы на каких чизических дисках находятся в lvm мы не знаем
смотрим на количество свободных экстендов

pvdisplay
PE SIXE = 4MiB
FREE PE  = 0   --диск полностью занят
чтобы ПЕРЕСЧИТАТЬ НА РАЗМЕР этого ДИСКА (СКОЛЬКО ОСТАЛОСЬ СВОБОДНОГО МЕСТА) нужно FREE PE УМНОДИТЬ НА  PE SIZE

при переносе информации нужно смотреть, чтобы на диске (в группе) который будет принимать информацию кол-во свободных
 экстендов было или равно или больше чем на диске источнике информации  --параметр FREE PE  (было достаточно свободного места в группе).
операция делается внутри группы - с плохого диска информация распределяется по оставшимся, а плохой диск становится пустым и готов к замене


ПЕРЕНОС ДАННЫХ
pvmove /dev/sdb (диск который хотим вынуть - источник данных) -v (чтобы смотреть процесс)  --процедура долгая!

проверим
pvdisplay
диск который мы хотим вынуть должен быьт свободный, т.е. параметры
TOTAL PE = 2047  --ЧИСЛЫ ДОЛЖНЫ СОВПАДАТЬ (тут число условно)
FREE PE = 2047  --ЧИСЛЫ ДОЛЖНЫ СОВПАДАТЬ

теперь диск удаляем из группы
vgreduce vg0 (из какой группы удаляем диск) /dev/sdb (какой диск удаляем)

смотрим
pvdisplay
/dev/sdb  --диск который хотим удалить
VG NAME -- пусто, т.е. не имеет группы

далдее удаляем метку с диска 
pvremove /dev/sdb

но если диск неисправен и работать на нем уже нельзя - то можено метку не удалять

диск можно вытаскивать из компьютера


после замены - смотрим как новый диск определился, пусть так же sdb
вводим его в группу
pvcreate /dev/sdb    --сделали метку, что будем использовать в lvm
vgextend vg0 /dev/sdb  --в какую группу и какое устройство добавляем

теперь в нашей группе опять 3 диска



ЧЕРЕДОВАНИЕ ЗАПИСИ ДАННЫХ НА РАЗНЫЕ ДИСКИ (АНАЛОГ RAID 0)
для этого в группе должно быть больше двух дисков
lvcreate -i2 -I32 -L2G -n raid0 vg1

-i2  -- на какое кол-во физических устройств в группе будет происходить расслоение данных

-I32  -- через сколько КБ будет происходить чередование 0 у нас 32кб пишется на первый диск и следуюзие 32кю на другой диск

-L2G  -- размер нашего логического тома

-n raid0  -- название этого логического тома 

vg1  -- в какой группе это делаем (выделяем)

далее нужно создать файловую систему на этом томе
mkfs.ext4 /dev/vg1/raid0

БЫТЬ ВНИМАТЕЛЬНЕЕ - ЕСЛИ ОДИН ИЗ ДИСКОВ ВЫХОДИТ ИЗ СТРОЯ - ВСЯ ИНФ ТЕРЯЕТСЯ


ИЗМЕНЯЕМ ЭКСТЕНДЫ (ПРИ СОЗДАНИИ ГРУППЫ)
vgcreate -s 1M vg1 /dev/sdb

-s 1M    -- задаем размер экстенда в 1Мб
vg1    -- в какой группе
/dev/sdb  -- на каком диске

ПРИ ДОБАВЛЕНИИ СЛЕДУЮЩИХ ДИСКОВ В ЭТУ ГРУППУ - РАЗМЕР ЭКСТЕНДА ТАК ЖЕ БУДЕТ 1МБ
