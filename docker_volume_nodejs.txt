(docker часть 3)

для информации - необходимо заглянуть в прошлие 2 файла
(в целом docker уже не модный - используй containerD)

запускаем react приложение в docker, будем использовать volume


вступление:

docker stats --no-stream         --потребление ресурсов
journalctl -fu docker            --смотреть журнал
sudo systemctl status docker     --статус докера 


=====================================

создадим docker_test и скопируем в него наш react проект - будем
подцеплять эту директорию в контейнер

на  docker hub  нет контейнера который одновременно node.js и nginx
будем качать только node.js

я нашел на сайте, но можно и 
docker search node

скачиваем обарз
docker pull node

образ не ляжет в нашу директорию, он будет храниться в системе
см - предыдущие 2 файла

будем считать, что на моем компьютере node.js, react и все необходимое
чтобы запустить react приложение есть

в нашей директории, где хранится react проект создаем файл и редактиркем его

nano Dockerfile

сожержит:


FROM node:latest         --используем последний образ node
WORKDIR /app             --задаем рабочую директорию - в контейнере 
                           будет создана новая папка
COPY package.json ./     --в эту папку контейнера копируем package.json 
RUN npm install          --и устанавливаем зависимости
COPY . .                 --все туда копируем
CMD ["npm", "start"]     --стартуем реакт (node.js) приложение


так же в корне создаем (с точкой) 
.dockerignore

в него запишем то, что не нужно утягивать в контейнер
в нашем приложении - это директория node_module
когда мы запустим npm install, чтобы получить доступ ко всем зависимостям 
в нашем приложении - это само по себе создаст папку node_modules

сожержит:

node_modules     --создасться само, наши старые данные там не нужны
Dockerfile       --файл конфига контейнера
.git             --git от нашего react проекта



Создание образа
Теперь, чтобы запустить наш контейнер, мы должны сначала запустить 
команду сборки. Эта команда выполняет каждый шаг, который мы определили 
в нашем Dockerfile файле

docker build -t react-t:latest .   (точка  - признак текущ директории)

--react-t  --название нашего образа, который мы создаем


Запуск контейнера
Чтобы запустить docker контейнер, напишим в терминале команду:

docker run --name nameofmycontainer -d -p 3000:3000 react-t:latest

-- nameofmycontainer - имя - последн колонка в 'docker ps'

--d: это запускает ваш контейнер в автономном режиме -detouch
    отдает терминал обратно

--p: переназначение портов, но у нас сейчас нет, но может быть 3000:80
    так же отдает порт наружу, иначе приложение так и останется
    только внутри контейнера


если все пойдет хорошо, увидим id контейнера, он уникальный,
но примерно выглядит так

9c6b6a734243cfe7f949185aa8b575d2cb51335538442e6a7b879197107b2247


можно посмотреть, что образ собрался
docker images

и посмотреть бегущие контейнеры
docker ps

или все контейнеры что есть
docker ps -a


теперь идем в браузер  ипри запущеном контейнер в адр строке набираем
(тут важно не забыть, если наше приложение рабоет в фоне от локального
реакта - то его остановить!)

localhost:3000

и мы должны будем увидеть приложение из контейнера
3000 порт - мы его не переопределяли

для остановки контейнера:
docker stop 9c6b6a73424

--9c6b6a73424  - id контейнера который останавливаем - берем из 'docker ps'





==========================


docker run -v /local/dir:/containr/dir

docker run -v /home/user:/mnt
т.е. папка /home/user с хостового сервера будет примонтирована в папку /mnt в контейнере

-v /var/log/syslog  - для монтирования отдного файла



docker run -d -P -v http-custom-data:/usr/share/nginx/html node 
запускаем докер с образа node.js
-d  detach запуск контейнера в фоне
-P, --publish-all                 Publish all exposed ports to random ports
-v, --volume value                Bind mount a volume (default []). The comma-delimited
                                    `options` are [rw|ro], [z|Z],
                                    [[r]shared|[r]slave|[r]private], and
                                    [nocopy]. The 'host-src' is an absolute path
                                    or a name value.



http-custom-data: - что подключаем
http-custom-data: -  куда подключаем

lalala_hdd:/tmp/lalala lalala

docker docker run -it -d -P -v lalala_hdd:/tmp/lalala2 lalala

lalala_hdd - папка которая на диске вне докера
/tmp/lalala2 - внутри работующего контейнера








простой запуск контейнер, но нам так не надо
docker run -it node
-it   --интерактивно - не отдаст шелл, будет бежать в нем пока его не прибъем
        ctrl + d завершит процесс и отдаст шелл

стк же
ctrl + c  --остановит выполнение контейнера (котор был запущен интерактивно)
            но это не корректный выход, возможна потеря данных

docker ps  --смотрим запущенные контейнеры, у них id

docker stop g37vgekrj
-остановка контейнера, правильная, g37vgekrj = id контейнера




