DOCKER

docker stats --no-stream   --потребление ресурсов
journalctl -fu docker      --смотреть журнал

---- подготовка и установка ----
-образы - некие шаблоны, чтобы из них создавались определенные контейнеры и они только для чтения
-контейнер - создаётся от этого образа и потом запускается на выполнение, именно в контейнере происходит работа нашего приложения или сервиса

компоненты:
docker engine - докер установленный на мой компьютер
комьюнити эдишн - бесплатная версия
docker container - бегущий (запущенный) контейнер (бегущая мини виртуальная машина)
docker image - не бегущий контейнер - его образ - (файл iso)
dockerfile - если создавать свой образ - нужно описать из чего этот образ будет состоять - ОС, что настроено... текстовый 
файл, пишем сами соблюдая docker синтаксис. (Писать с большой буквы D)  Пример файла:

docker pull node
-чтобы получить контейнер - зайти на https://hub.docker.com/ , в поиске найти нужный контейнер (node) и стянуть его. Если не указывать определенную версию - скачается последняя версия.

FROM amazonlinux - используем амазонлинукс, который уже существует
RUN yum -y update
RUN yum -y install httpd
RUN echo 'hello world' > /var/www/html/index.html
CMD ["/usr/sbin/httpd", "-D", "FOREGROUND"] - запустить сервис апач
ENV PORT 4200 - окружение, тут задаем порт на котором будет доступно приложение, но в этом случае нужно у параметра EXPLOSE указывать $PORT - переменная
EXPOSE 80 - открыть порт 80 - (порт на котором работает приложение внутри контейнера)
(теория - каждая комманда это определенный слой - см мануал по докеру)

этот файл мы созраним, потом запустим BUILD этого файла, после окончания билда у нас создасться докер image
можем сделать RUN и запуститься docker контейнер

зайти на docker.com - раздел Products - скачать и установить docker engine

Устанавливаем:
apt install apt-transport-https
- установить, чтобы использовать https для скачивания с репозиториев. Может возникнуть проблема, лечится apt-get update, а может придется вернуться и к http.

curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
- скачать и установить ключик и добавим в наше repo

sudo add-apt-repository "deb [arch=amd64] https://download.docker.com.linux/ubuntu $(lsb_release -cs) stable"
-комманда в которой мы говорим, что хотим скачивать только стабильные версии и только оттуда

sudo apt update
- просто обновим репозитории

sudo apt install docker-ce
- устанавливаем сам докер (ce = CommunityEdition - который бесплатный)

sudo systemctl status docker
-проверяем, что докер запущен (выполняется)

все комманды для докера запускать через sudo (или под рутом), чтобы от этого избавиться:
sudo usermod -aG docker $USER
- добавим текущего (себя) пользователя в группу docker, после перелогиниться


----работа с докер----
# запуск докерА

docker run hello-world
- попытка запустить образ hello-world - будет искать чтобы запустить, если не найдет, то полезет в интернет и скачает этот образ и потом запустит - служит для теста

docker images
-пролистать, какие образы есть
docker image ls
- тоже самое

https://www.docker.com/products/docker-hub перекинет по назатию кнопки на https://hub.docker.com
откуда брать образы (чтобы не делать самому), там и посмотреть, каие образы существуют

docker search tomcat
- ищем образ tomcat в докер хабе через консоль (не заходя на сайт)

docker pull tomcat
- просто скачать образ tomcat и ничего не делать

docker run tomcat
- скачать и запустить (сразу) образ

docker run -it -p 1234:8080 tomcat
-запустить контейнер из образа, но прежде нужно провеврить какой ip адрес на сервере на котором запускаем докер (свсоего пк) 
(чтобы обращаться в случае чего или использовать localhost, но это из сети не доступно)
-it = интерактивно, т.е. будем видеть как этот контейнер бежит (не бэкграунд, коммандная строка не отдастся пока не отрубим этот контейнер)
-p = перенаправление портов хотим получить доступ по порту 1234 а 8080 изначально на котором работает сервис - т.е. в контейнере открыт 
только этот порт, на котором он бы запустился по умолчанию, но мы его перенаправили и на нашем пк сервис будет работать на 1234 порту.
tomcat = название самого образа, которого запускаем

[ctrl]+[c]
- остановит выполнение контейнера (котор был запущен интерактивно), но это не корректный выход, возможна потеря данных

docker stop g37vgekrj
-остановка контейнера, правильная, g37vgekrj = id контейнера

docker run -it node
- запустится контейнер node.js и мы получим интерпретатор (bash) node.js, можно в нем работать как в коммандной строке. Это отличается от 
"захода в контейнер", нужно быть внимательнее, у каждого образа свои особенности.

docker run -d -p 1235:8080 tomcat
-d = запустить в фоне (отдаст коммандную строку)
после выдастн id нашего контейнера (длинный хэш)
мы тут специально изменили порт, таким образом можно запускать на выполнение несколько одинаковых контейнеров

docker run -d -p 12347:80 nginx
- пробуем запустить контейнер nginx, предварительно не скачав образ

run - при запуске, служит для генерации контейнера и ему нужно указывать образ, как параметр, для запуска, поэтому если запускать через 
run - будет генериться новые контейнеры, при каждом запуске.

docker start g37vgekrj
-запустит контейнер в фоновом режиме , эквивалент -d, где g37vgekrj = id контейнера
- возможно нужно указывать -p ,  иначе не будет работать, но это не точно, возможно придется обращаться на тот порт, который указанн в 
EXPOSE чтобы "увидеть" приложение, вообще нужно указывать -p, если запускаем через run


если не указывать тэг, то контейнер будет запускаться будет запускаться с тэгом latest
docker run -d -p 12347:80 nginx:v1
- запустит контейнер nginx у которого тэг v1 (тэги разные - нимательнее)

docker run - создает новый контейнер при запуске, поэтому переодически нужно не нужные удалять (см дату запуска и id и название)


docker ps
- показывает какие контейнеры сейчас запущены (выполняются)

docker ps -a
- показать все конетйнеры который когда либо выполнялись

docker -rm wello-world
- удаляем сначала контейнер (они принадлежать образу), только потом образ
-rm = комманда для удаления колнтейнера

docker -rmi hello-world
- удаляем образ
-rmi - remove images
-hello-world сам контейнер который хотим удалить

docker image prune
- удалит все неиспользуемые образы

docker image prune --help
вызовет помощь о image prune 

docker container prune
-удалит все остановленные и не использованные контейнеры


docker exec -it 87b6rd54e5g /bin/bash
- заходим внутрь контейнера
-exec для захода внутрь
-it интерактивно
-87b6rd54e5g - ID контейнера
-/bin/bash - запустить оболочку при подключении (мы подключились к контейнеру и получили его bash)

exit - выходим из контейнера обратно в наш пк

----создаём свой контейнер и образ ----
(можем создать файл .env, куда запишем все наши переменные, например:
PORT=4200
чтобы эту настройку подцепить, строка запуска будет след:
docker run -d -p 80:4200 --env-file ./config/.env -name logsapp logsapp:env
где ./config/.env - путь до .env файла
)
для начала создать пустую директорию и зайти туда, потом создадим файл Dockerfile - с большой буквы!! и без расширения (файл инструкций для 
создания нового образа)! Внутри напишем:

-FROM названияОбраза, при создании докер будет смотреть если ли у нас локально этотОбраз, если нет - скачает из своего репозитория (докер 
хаб), если не найдет такого образа - будет ошибка
- LABEL — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.
- ENV — устанавливает постоянные переменные среды.
-COPY указатьНашиФайлы, которые будут скопированы из нашего проекта  в наш образ
COPY .  (точка) - все сущности которые находятся в корне проекта (корен проекта - там где лежит Dockerfile)
COPY . . (вторя точка) - то место, куда мы положим файлы в образе - точка - значит положим в корень, но обычно мы создаем папку, которая будет 
служить корнем для всего нашего проекта, выглядит например так:
COPY . /app
или же:
-WORKDIR /app (указывает где будут лежать все наши файлы проекта) - WORKDIR пишется перед COPY, после в COPY оставить или абсолютный 
путь /app или . . (2 точки), потому что мы и так находимся в контексте папки app
-RUN npom install - запуск на выполнение комманды, в этом случае устанавливаем npm. RUN - запускается когда мы собираем и строим сам образ. 
-CMD ["node", "app.js"] - запускает на выполнение программу (приложение) в контейнере. Это массив, который сожержит в себе несколько элементов и 
каждый элемент представлен в виде одной комманды. Тут мы вызываем node и передаем на выполнение app.js. - CMD запускается каждый раз, когда мы 
запускаем этот образ (выполняет программу внутри образа)
ENV PORT 4200 - окружение, тут задаем порт на котором будет доступно приложение, но в этом случае нужно у параметра EXPLOSE указывать $PORT - переменная
-EXPOSE - не является обязательной, но это "best practice" - говорит - какой порт выставить наружу, (на каком порту будет висеть наше приложение)
- VOLUME — создаёт точку монтирования для работы с постоянным хранилищем.

FROM node
WORKDIR /app
COPY . .
RUN npm install
CMD ["node", "app.js"]
ENV PORT 4200 - окружение, тут задаем порт на котором будет доступно приложение, но в этом случае нужно у параметра EXPLOSE указывать $PORT - переменная
EXPOSE 3000 - порт на котором работает приложение внутри контейнера, незабыть при запуске указать локальный порт через параметр "-p"

создаем образ:
docker build . (точка) - поскольку все, в т.ч. и Dockerfiles лежат в одной папке - ставим точку, далее образ создается. Хорошей практикой сразу давать 
имя (уникальное) иначе образ создасться без имени и тэга и отличать его придется по времени создания и id, что не очень удобно, если образов много.

##ИЗМЕНЕНИЕ В ПРОЕКТЕ
-Если мы В ПРОЕКТЕ ЧТО ТО ИЗМЕНИЛИ, то нам нужно это (изменения) запихнуть в образ, т.е. собрать новый (или модифицировать текущ контейнер)
docker build . - создаем новый образ (там будут изменения из проекта, рабочих, накопленных, данных - не будет, т.е. это ВНОВЬ СОЗДАННЫЙ образ)! а из 
него потом создадим контейнер,. который и запустим, который будет содержать обновления.

---- оптимизация работы (создания образа) ----
Есть НЮАНС, если мы внесли изменения в код, но не в процесс собирания образа, то, например, RUN npm install выполнится опять, но это нам уже не нужно, докер 
кэширует много всего. Докер понимает, что походие образы у нас где то уже присутствуют (в которых npm install уже выполнено), докер смотрит в кэш и не делает 
лишнюю работу. Поэтому мы можем оптимизировать работу связанную с node модулем - модифицируем наш Dockerfile:
FROM node
WORKDIR /app
COPY package.json /app
RUN npm install
COPY . .
CMD ["node", "app.js"]
ENV PORT 4200 - окружение, тут задаем порт на котором будет доступно приложение, но в этом случае нужно у параметра EXPLOSE указывать $PORT - переменная
EXPOSE 3000

теперь, если мы не будем никак менять node модули, то мы будем брать их из кэша и избавимся от лишней работы (скачавания и установки npm по новой, например). 
Пересобираемм образ: 
docker build . (точка)

можем создать папку .dockerignore (в переди точка)
и писать туда, что НЕ нужно добавлять в образ (похоже на интсрукцию от git)
просто перечислять, например
node_modules
.idea - служебная папка от webshtorm
.git
Dockerfile - точно не потребуется т.к. это инструкция для построения образов (в свмом образе не нужен)


docker inspect apps
- смотрим лог, чего в образе apps насобиралось, есть комманды RUN, есть цепочки слоёв


## ---- комментарии и ПРИМЕРЫ по созднию оюразов----
FROM ubuntu:16.04 - образ который используем, 16.04 - тэг

RUN yum -y update
RUN yum -y install apache2

RUN echo 'hello world' > /var/www/html/index.html
CMD ["/usr/sbin/apache2ctl", "-DFOREGROUND"] - запустить сервис апач
ENV PORT 4200 - окружение, тут задаем порт на котором будет доступно приложение, но в этом случае нужно у параметра EXPLOSE указывать $PORT - переменная
EXPOSE 80 - открыть порт 80 - порт на котором работает приложение внутри контейнера, незабыть при запуске указать локальный порт через параметр "-p"

теперь из этого создаем наш образ

docker build -t denis:v1 . (точка)
--tag , -t Name and optionally a tag in the 'name:tag' format
- denis - название образа
- v1 - добавили тэг (но можно и не добавлять, тогда присвоти тэг = latest)
-   . (точка) - значит локально найдет докер файл
увидит, что ubuntu образа нет - скачает с гитхаб, запустит прописанные нами комманды (apt update), установит апач и создаст наш образ с 
именем denis, скаченный образ ubuntu останется в папке

docker tag denis:v1 denis:copy
- меняем тэг путем создания дубликата контейнера - т.к. зоздается копия - внимание на место на диске

docker build -t myimage:latest .
-Создать Image с именем myimage:latest из локального Dockerfile, latest - это тэг
--tag , -t Name and optionally a tag in the 'name:tag' format


еще раз cделаем образ
перед этим, создадим файлик index.py, в котором будет код на питоне и завернем его в контейнер и будем запускать

FROM python - взять образ питона

WORKDIR /app - обозначить корневую директорию
COPY . . - копируем свои файлы

CMD ["python" "index.py"] - обратимся к питону и запустим наш файлик index.py
потом в консоле пишем:
docker build - если сделать так, то имя и тэг будут пустые, запуск будет возможен только по id, поэтому все же создадим файлик с именем:
docker build -t my_py . (точка), опять же не дописали тэг, ну и ладно
--tag , -t Name and optionally a tag in the 'name:tag' format - тут, вроде, тэг не дописан!

----изменяем содержимое контейнера (внутри контейнера)----
docker exec -it 87b6rd54e5g /bin/bash
- заходим внутрь контейнера
-exec для захода внутрь
-it интерактивно
-87b6rd54e5g - ID контейнера
-/bin/bash - запустить оболочку при подключении (мы подключились к контейнеру и получили его bash)
cd /var/www/html - проходим к нашему файлу который будем менять
index.html - там он лежит и редактируем его, но редактировать не получится, там нет nanno и vi вероятно тоже нет, придется как то ставить.

exit - выходим из контейнера обратно в наш пк


---- подключаемся к контейнеру в консоле и немного непонятного, и прочие опции----
docker ps - смотрим запущенные контейнеры, смотрим там id контейнера (или имя контейнера)
docker attach mf9m6h673
-mf9m6h673 = id контейнера
и сейчас мы провалились во внутрь процесса который запущен внутри докер контейнера (курсор просто перешел на новую строку)

docker logs mf9m6h673
-mf9m6h673 = id контейнера
смотрим, что происходило внутри контейнера, покажет на каком порту запущен, чего выдает (делает)

docker run -d -p 3000:3000 --name logsapp mf9m6h673
-mf9m6h673 = id контейнера
--name logsapp
задаем СВОЁ ИМЯ КОНТЕЙНЕРА, чтобы проще ориентироваться, а не использовать случайную генерацию имен, и теперь мы уже знаем своё имя 
(и помним его) и нам не нужно каждый раз набирать docker ps

docker run -d -p 3000:3000 --name logsapp --rm mf9m6h673
--rm - как только мы остановим контейнер он будет автоматически удален (чтобы не скапливались ненужные (тестовые например))


создадим образ с тэгом
docker build -t logsapp:exc . (точка)
запустим этот образ (который с тэгом), если тэг не указывать то будедт автоматически подставлен тэг latest
docker run -d -p 3000:3000 --name logsapp logsapp:exc
тут logsapp:exc = образ с тэгом

----делаем из старого образа новый образ -----
после сделаных изменений, делаем новый образ

docker commit 87b6rd54e5g denis:v2
-87b6rd54e5g - ID контейнера (старого)
-denis:v2 - наш новый контейнер

----обмен образами ----
файл образа мы не увидим, обмен идет через докер хаб, т.е. чтобы файл кому от отдать - нужно этот файл заслать на докер хаб и дать ссылку на 
скачивание. Регистрируемся, делаем docker login,  docker push
и так - логинимся в докер через консоль:
docker login
теперь необходимо переименовать (но мы скопируем) наш образ logsapp в metelkov/logsapp
docker tag logsapp metelkov/logsapp
старый образ никуда не исчез, мы скопировали его и копии дали новое имя
далее засылаем нужный нам образ:
docker push metelkov/logsapp:latest 

где metelkov = наш репозиторий (наша директория) куда мы будем заливать образ и metelkov/logsapp:latest = наш образ с тэгом latest

чтобы кто то его теперь скачал - должны выполнить комманду:
docker pull metelkov/logsapp

файл скачали и теперь его запустим
docker run -d -p 4200:3000 --rm --name logsapp metelkov/logsapp
тут logsapp - имя контейнера, который запускается от образа metelkov/logsapp (metelkov/logsapp = файл образа)

---- пишем скрипт для запуска ----
создаем файл makefile, и в нем описывать различные комманды.
синтаксис файла:
run:
    docker run -d -p 80:4200 --env-file ./config/.env -rm --name logsapp logsapp:env
(дожен стоять make на компьютере, запуск - make run)
stop:
    docker stop logsapp
(теперь, чтобы остановить нужно написать make stop)

---- VOLUME ----
например, у нас есть файл logs.txt, в который мы заносим какие то изменения при работе с программой и которая что то пишет на диск. Но программа 
запущена в контейнере и пишет соответственно внутрь контейнера и при остановке контейнера, если он запущен с ключом --rm контейнер будет удален и 
данные м ы потеряем, а если нет --rm, то данные внутри контейнера останутся.
VOLUME - некая папка, которая хранится на нашем (локальном) пк, хз где (см ниже) и докер туда все складывает, эту папку мы может использовать как 
общую для различных контейнеров, которые могут получить к ней доступ. Сам контенер, так же, может обратиться к определенному VOLUME и брать данные оттуда.
Есть 2 типа volume - анонимные и именованные. Анонимный volume  удаляется, когда удаляется сам контейнер. 
1. способ, можем добавить в файл Dockerfile при построение образа:
FROM node
WORKDIR /app
COPY . .
RUN npm install
CMD ["node", "app.js"]
ENV PORT 4200 - окружение, тут задаем порт на котором будет доступно приложение, но в этом случае нужно у параметра EXPLOSE указывать $PORT - переменная
EXPOSE 3000 - порт на котором работает приложение внутри контейнера, незабыть при запуске указать локальный порт через параметр "-p"
VOLUME [ "/app/data" ]
-volume это массив, где мы указываем путь до нашего volume
/app - контекст, где лежит у нас приложение - см WORKDIR /app
data - те временные файлы, которые понадобятся для работы приложения непосредственно

**************** 18:00

docker run -d -p 127.0.0.1:8080:80 -v /opt/docker_vol/nginx_php:/var/www/html хэш_контейнера
-монтируем папку на локальном пк в контейнер в папку внутри докера
-/opt/docker_vol/nginx_php: = имя папки шары которая хранит содержимое, которое будем впиивать в контейнер
-/var/www/html = куда в контейнера будет примонтирована папка

docker run -d -p 127.0.0.1:8080:80 -v dir_nginx_php:/var/www/html хэш_контейнера
тут монтируем volume внутри докера


есть 2 типа волюумов - анонимные и именованные
анонимный волиум удаляется, когда удаляется сам контейнер, но нам это не нужно
т.к. мы хотим сохранить эту базу данных, не смотря на то, что мы будем менять различные контейнеры. для этого, чтобы указать, что мы хотим работать с 
дополнительным волиумом нужно передать параметр -v  

docker run -d -p 127.0.0.1:8080:80 -v  logs:/app/data --rm --nmae logsapp logsapp:volume
* logs: - название, двоеточие - разделяет
* /app/data - путь до волиума, который мы указали в докерфайле
* именновынный волиум не удалится после остановки контейнера
*чтобы посмотреть что есть внутри волиума - 
docker volume inspect logs 
где logs - имя волиума
внутри найдем инф - драйвера, точку монтирования, дату создания. но путь монтирования находится не на компьютере, а внутри самого докера

создать свой волиум -
docker volume ls



как задеплоить проект на докере (чтобы видели другие)
понадобится облачный сервер (vscale)
*нужна система, на которой установлен докер м на ней делаем
docker pull vladilenm/logaspp:volumes - мы его предварительно на докерхаб
запихали, а теперь берем оотуда этой коммандой и потом запускаем его
docker run -d -p 80:3000 --name logsapp --rm valadilenm/logsapp:volumes
и теперь смотрим по какому адресу доступен наш сервер и переходим на этот адр
, там будет работать контейнер и мы будем пользоваться им



docker search 1c - какие контейнеры можно скачать и использовать
docker attach хэш - присоедениться к контейнеру
docker inspect lalala - смотреть, что в шаре
docker port $(docker ps -lq) - смотреть, на каком порту крутиться сервис (роеальный)
docker run -d --network=my-net --ip=10.10.20.30 busybox - подключить контейнер к сети, добавим контейнер busybox к 
сети my-net, --ip = ipдля контейнера в пользовательской сети
-для добавления запущенного контейнера к сети - docker network connect
- отключить контейнер от сети docker network disconnect


docker save хэш_контейнера > 1_save.tar
в текущ директории создаст 1_save.tar - готов для переноса

docker load < ubuntu.tar.gz
docker load --input ubuntu.tar
загрузка
*******************

Export/Import Docker Image to file
docker save image:tag > arch_name.tar
docker load -i arch_name.tar

