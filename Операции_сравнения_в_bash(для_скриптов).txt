Операции сравнения  в  bash  (для скриптов)

***сравнение целых чисел***

равно
-eq
if [ "$a" -eq "$b" ]


не равно
-ne
if [ "$a" -ne "$b" ]

больше
-gt
if [ "$a" -gt "$b" ]

больше или равно
-ge
if [ "$a" -ge "$b" ]

меньше
-lt
if [ "$a" -lt "$b" ]

меньше или равно
-le
if [ "$a" -le "$b" ]


меньше (внутри двойных круглых скобок )
<
(("$a" < "$b"))

меньше или равно (внутри двойных круглых скобок)
<=
(("$a" <= "$b"))

больше (внутри двойных круглых скобок)
>
(("$a" > "$b"))

больше или равно (внутри двойных круглых скобок)
>=
(("$a" >= "$b"))


***сравнение строк***

равно
=
if [ "$a" = "$b" ]

равно
==
if [ "$a" == "$b" ]

Синоним оператора =.

[[ $a == z* ]]    # истина, если $a начинается с символа "z" (сравнение по шаблону)
[[ $a == "z*" ]]  # истина, если $a равна z*

[ $a == z* ]      # имеют место подстановка имен файлов и разбиение на слова
[ "$a" == "z*" ]  # истина, если $a равна z*



не равно
!=
if [ "$a" != "$b" ]

Этот оператор используется при поиске по шаблону внутри [[ ... ]].

<
меньше, в смысле величины ASCII-кодов
if [[ "$a" < "$b" ]]
if [ "$a" \< "$b" ]

Обратите внимание! Символ "<" необходимо экранировать внутри [ ].

>
больше, в смысле величины ASCII-кодов
if [[ "$a" > "$b" ]]
if [ "$a" \> "$b" ]

Обратите внимание! Символ ">" необходимо экранировать внутри [ ].

См. Пример 25-6 относительно применения этого оператора сравнения.

-z
строка "пустая", т.е. имеет нулевую длину

-n
строка не "пустая".

Caution	
Оператор -n требует, чтобы строка была заключена в кавычки внутри квадратных скобок. Как правило, проверка строк, не заключенных в кавычки, оператором ! -z, или просто указание строки без кавычек внутри квадратных скобок (см. Пример 7-6), проходит нормально, однако это небезопасная, с точки зрения отказоустойчивости, практика. Всегда заключайте проверяемую строку в кавычки. 


Пример 7-5. Операции сравнения

#!/bin/bash
a=4
b=5
#  Здесь переменные "a" и "b" могут быть как целыми числами, так и строками.
#  Здесь наблюдается некоторое размывание границ
#+ между целочисленными и строковыми переменными,
#+ поскольку переменные в Bash не имеют типов.
#  Bash выполняет целочисленные операции над теми переменными,
#+ которые содержат только цифры
#  Будьте внимательны!

echo

if [ "$a" -ne "$b" ]
then
  echo "$a не равно $b"
  echo "(целочисленное сравнение)"
fi

echo

if [ "$a" != "$b" ]
then
  echo "$a не равно $b."
  echo "(сравнение строк)"
  #     "4"  != "5"
  # ASCII 52 != ASCII 53
fi

# Оба варианта, "-ne" и "!=", работают правильно.

echo
exit 0


Пример 7-6. Проверка -- является ли строка пустой
#!/bin/bash
# str-test.sh: Проверка пустых строк и строк, не заключенных в кавычки,
# Используется конструкция   if [ ... ]


# Если строка не инициализирована, то она не имеет никакого определенного значения.
# Такое состояние называется "null" (пустая) (это не то же самое, что ноль).

if [ -n $string1 ]    # $string1 не была объявлена или инициализирована.
then
  echo "Строка \"string1\" не пустая."
else
  echo "Строка \"string1\" пустая."
fi
# Неверный результат.
# Выводится сообщение о том, что $string1 не пустая,
#+не смотря на то, что она не была инициализирована.

echo

# Попробуем еще раз.
if [ -n "$string1" ]  # На этот раз, переменная $string1 заключена в кавычки.
then
  echo "Строка \"string1\" не пустая."
else
  echo "Строка \"string1\" пустая."
fi      # Внутри квадратных скобок заключайте строки в кавычки!

echo


if [ $string1 ]       # Опустим оператор -n.
then
  echo "Строка \"string1\" не пустая."
else
  echo "Строка \"string1\" пустая."
fi
# Все работает прекрасно.
# Квадратные скобки -- [ ], без посторонней помощи определяют, что строка пустая.
# Тем не менее, хорошим тоном считается заключать строки в кавычки ("$string1").
#
# Как указывает Stephane Chazelas,
#    if [ $string 1 ]   один аргумент "]"
#    if [ "$string 1" ]  два аргумента, пустая "$string1" и "]"



echo



string1=initialized

if [ $string1 ]       # Опять, попробуем строку без ничего.
then
  echo "Строка \"string1\" не пустая."
else
  echo "Строка \"string1\" пустая."
fi
# И снова получим верный результат.
# И опять-таки, лучше поместить строку в кавычки ("$string1"), поскольку...


string1="a = b"

if [ $string1 ]       # И снова, попробуем строку без ничего..
then
  echo "Строка \"string1\" не пустая."
else
  echo "Строка \"string1\" пустая."
fi
# Строка без кавычек дает неверный результат!

exit 0



Пример 7-7. zmost
#!/bin/bash
#Просмотр gz-файлов с помощью утилиты 'most'

NOARGS=65
NOTFOUND=66
NOTGZIP=67

if [ $# -eq 0 ] # то же, что и:  if [ -z "$1" ]
# $1 должен существовать, но может быть пустым:  zmost "" arg2 arg3
then
  echo "Порядок использования: `basename $0` filename" >&2
  # Сообщение об ошибке на stderr.
  exit $NOARGS
  # Код возврата 65 (код ошибки).
fi

filename=$1

if [ ! -f "$filename" ]   # Кавычки необходимы на тот случай, если имя файла содержит пробелы.
then
  echo "Файл $filename не найден!" >&2
  # Сообщение об ошибке на stderr.
  exit $NOTFOUND
fi

if [ ${filename##*.} != "gz" ]
# Квадратные скобки нужны для выполнения подстановки значения переменной
then
  echo "Файл $1 не является gz-файлом!"
  exit $NOTGZIP
fi

zcat $1 | most

# Используется утилита 'most' (очень похожа на 'less').
# Последние версии 'most' могут просматривать сжатые файлы.
# Можно вставить 'more' или 'less', если пожелаете.


exit $?   # Сценарий возвращает код возврата, полученный по конвейеру.
# На самом деле команда "exit $?" не является обязательной,
# так как работа скрипта завершится здесь в любом случае,
построение сложных условий проверки

-a
логическое И (and)

exp1 -a exp2 возвращает true, если оба выражения, и exp1, и exp2 истинны.

-o
логическое ИЛИ (or)

exp1 -o exp2 возвращает true, если хотябы одно из выражений, exp1 или exp2 истинно.

Они похожи на операторы Bash && и ||, употребляемые в двойных квадратных скобках.

[[ condition1 && condition2 ]]
Операторы -o и -a употребляются совместно с командой test или внутри одинарных квадратных скобок.
if [ "$exp1" -a "$exp2" ]


Чтобы увидеть эти операторы в действии, смотрите Пример 8-3 и Пример 25-11.

Примечания
[1]	
Как указывает S.C., даже заключение строки в кавычки, при построении сложных условий проверки, может оказаться недостаточным. [ -n "$string" -o "$a" = "$b" ] в некоторых версиях Bash такая проверка может вызвать сообщение об ошибке, если строка $string пустая. Безопаснее, в смысле отказоустойчивости, было бы добавить какой-либо символ к, возможно пустой, строке: [ "x$string" != x -o "x$a" = "x$b" ] (символ "x" не учитывается).