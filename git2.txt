конфиг системы, покрывает всех пользователей системы (пока не делал)git config --system

конфиг текущ репозитория (пока не делал)git config --local
указать себя, чтобы было видно, что это ты пушишь, что твой коммит
git config --global user.name "твое имя которым ты подписываешься"
git config --global user.emain "твоя_поята@субдомен.домен"

чтобы это посмотреть
git config -l
или (в домашней папке)
cat .gitconfig

начинаем работать:
чтобы создать репозиторий/новый проект в директории пишем
git init

посмотреть ветку, какие файлы изменились какие отправлены на удаленный репоз
git status

добавить файл
git add имя_файла1, имя_файла2,...
добавить все файлы
git add .  (точка)
или
git add * (имя_файл*.tx*)

чтобы игнорировать (не запихивать в гит) некоторые файлы и директории (служебные, не относящиеся к проекту)
-создаем в корне нашего проекта файл .gitignore и внутри этого файла писать, что не включать а гит
(имя.файла, *.расширение, директория/ (внимание на слэш))
при этом .gitignore нужно будет добавить в гит (git add .gitignore)

сделать коммит (версию файла/сделать снимок)
git commit -m "сообщение, что было сделано"

посмотреть все коммиты и их номера
git log

посмотреть последний коммит
git log -1

посмотреть последние коммита
git log -2

посмотреть, что было сделано (какие изменения) в последнем коммите
git log -1 -p

отменить последние изменения в файле (вернуть до прошлого сохранения)
git checkout -- испорченный_файл.расширение (внимание пробелы)

показать различия и что будет записано в git log перед тем как сделать коммит
(показ разницы между записанным и последним коммитом)  --staged именно стэйдж состоянии (добавленном) если заслать в индекс (стэйдж) и сделать log  без --staged  то ничего не покажет, т.к. все ушло в индекс
git diff --staged

заслать на удаленный репозиторий
git push
(git push origin)

показать в каком репозитории сейчас находимся (куда засылает файл) и получить ссылку
git remote -v

показать ветки
git branch(git branch -a)

создать ветку (просто создать)
git branch my_new_branch

перейти на ветку
git checkout my_new_branch

создать и сразу перейти в новую ветку
git checkout -b my_new_branch

чтобы удалить ветку (в нашем компьютере, локальную) 
1. переходим обратно в мастер (или др ветку)
git checkout master
2. теперь удаляем ветку
git branch -d my_new_branch
(git branch -d ветку_которую_хочу_удалить)

для удаления локальной (в нашем компьютере, локальную) ветки в которую сделали коммит
1. переходим обратно в мастер (или др ветку)
git checkout master
2. теперь удаляем ветку
git branch -D my_new_branch
(git branch -D ветку_которую_хочу_удалить)

для удаления ветки на сервере
git push origin --delete ветка_для_удаления

для соединения (слияния веток) с мастером
git branch my_new_branch
git branch (ветку_которую_хочу_слить_в_мастер)

чтобы вернуться, посмотреть, старую версию коммита (на прошлое содержание файла, откат версий)
1. смотрим версии
git log
2. возвращаемся на старую версию
git checkout длинный_хэш_нужной_версии_для_возврата
3. мы теперь не в какой ветке, можем смотреть файл
4. для возврата в обычный режим 
git checkout master
теперь опять файл со всеми последними изменениями, т.е. как был

изменить последний (или не последний) коммит, чтобы не делать новый, а изменить существующий
(открывает редактор для смены сообщения)
1. изменяем или добавляем файл
git commit --ammend
откроется редактор vi и там сделать все изменения 

для удаления коммитов (версий) безвозвратно удалить и откатиться до прошлой версии
(тут возвращаемся на 2 коммита назад) 
git reset --hard HEAD~2

для удаления коммитов, но остаться на последней версии файла
(удаляем 3 коммита, но не трогаем изменения в файле, будем как будто на первом коммите, но файл будет последней версии)
git reset --soft HEAD~3 
----------------
git checkout -h
git fetch - собирает все коммиты из целевой ветки, которых нет в текущей ветке, и сохраняет их в локальном репозитории. Однако он не сливает их в текущую ветку. Она забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.
git pull - сливает все коммиты в ветку, не давая сначала посмотреть их. Если вы не пристально следите за ветками, выполнение этой команды может привести к частым конфликтам.

git reflog - По умолчанию команда git reflog выводит журнал ссылок для указателя HEAD.
git reflog show _имя_ветки_ - просмотреть журнал ссылок для конкретной ветки, передайте имя этой ветки команде
git show --pretty="" --name-only bd61ad98
Эта команда выводит список всех файлов, задействованных в коммите

git push -u origin main  

===========залить в пустую новую веткуmkdir 003_cafe
cd 003_cafe/
git init
git add .
git commit -m "initial commit"
git remote -v
git remote add origin https://github.com/Metelkov/003_frontend_cafe_figma_template.git
git remote -v
git push
git push --set-upstream origin master
git status

===============================удалит репозиторий paul
git remote rm paul

переименуем репозиторий из pb в paul
git remote rename pb paul

соединяем локальный и удаленный репозитории
git push -u origin master


git reflog
вы увидите список всего,
что сделали в git, во всех ветках!
у каждого элемента есть индекс HEAD@{индекс}
найдите тот, перед которым всё сломалось
git reset HEAD@{index}
волшебная машина времени


пытаюсь открыть diff, но ничего не происходит
Если вы уверены, что изменили файлы, но diff пуст, 
возможно вы индексировали изменения (add) и нужно добавить специальный флаг.
git diff --staged


нужно отменить коммит, который был 5 коммитов назад!
- найдите коммит, который нужно отменить
git log
используйте стрелочки, чтобы прокрутить историю
сохраните хеш нужного коммита
git revert [сохранённый хеш]
git создаст новый коммит, отменяющий выбранный
отредактируйте сообщений коммита
или просто сохраните


нужно отменить изменения в файле!
- найти хеш коммита, до которого нужно откатиться
git log
используйте стрелочки, чтобы прокрутить историю
сохраните хеш нужного коммита
git checkout [сохранённый хеш] -- путь/к/файлу
старая версия файла окажется в вашем индексе
git commit -m 

-----------------------------------------просмотреть изменения в веткахгде нет * можно удалять, их уже слилиgit branch -v

забрать с репозитория, чего не сохранено локальноgit fetch------------------------------------------git status -s — краткий вид изменений
git diff — показать изменения в файлах, которые еще не были добавлены в индекс коммита (staged)
git commit --amend — добавить изменения к последнему коммиту
git rm [file] — удалить файл из рабочей директории и добавить в индекс информацию об удалении
git remote -v — посмотреть детальный список доступных удаленных репозиториев
git remote add [remote][url] — добавить новый удаленный репозиторий
git mv file_from file_to - переименовать файл в Git
  git mv file_from /new_dir/file_to - перенести и переименовать файл в Git  
----------------------------
слить ветку с масте_веткой

git checkout style
git merge master

если будут конфликты

 1064  git fetch origin
 1065  git pull origin master
 1066  git add .
 1067  git pull origin master
 
хз, вроде тоже помогает от конфликтов

 1069  git pull origin master
 1070  git commit -m "all finished"
 1071  git pull origin master
 1072  git diff --staged
 1073  git diff
-------------------------------------------создаем новый проект и новый репозиторий - все новое, все по новой
…or create a new repository on the command line
echo "# 004_store_bem_layout" >> README.md
git init(git init repo_name - создаст в папке директорию repo_name где будет проанализирован новый гит - создавать в корне, потом войти в эту папку)
git add README.mdgit add .
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:Metelkov/004_store_bem_layout.git
git push -u origin main
                
…or push an existing repository from the command line
git remote add origin git@github.com:Metelkov/004_store_bem_layout.git
git branch -M main
git push -u origin main===================git show _hash_summ_ - покажет дтальное изменение коммита к которой привязана эта сумма

git commin -am "some message for commit" - a возмет все файлы которые были под версионным контролем и добавит их (исключает git add *)

git restore --staged _file_ - вернет изменение в файле, НО который НЕ попал в индекс. так же отменит удаление которое сделано git rm _file_
пример с удалением:
git restore --staged _file_ - файл уходит из индекса
git restore _file_ - вернет сам файл в файловую систему на ПК, можно опять заслать его в индекс


git rm --cashed _file_ удалит файл в индексе, но на файловой системе на ПК должен файл оставить, файл увидется в гите как не отслеживаемый

git reset --hard _hash_commit_ - передвигаем указатель head на старый (_hash_commit_) коммит, состояние файла перейдет на состояние указанного коммита, а коммиты "с которых съехали" более не будут видны в истории изменений


git remote add origin _ссылка_на_удаленный_репозиторий_ - подключаем к нашему проекту репозиторий, где origin - имя удаленного сервера (используется по умолчанию, если он один в проекте)

git remote -v - покажит какие есть репозитории (все)

git pull origin master - стянуть к себе изменения с сервера origin с ветки master


git fetch origin  - с локальным репозиторием ничего не произойдет, но скачается с origin все, что там было изменено и передвинется локально ветка слежения, потом, чтобы увидеть изменение нужно слить свою и удаленную ветку - git merge origim/master , потом можно делать свой push