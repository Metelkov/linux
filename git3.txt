git от 20231027 через https


для создания нового (добавлдения с нуля)
git init
git add .
git commit -m "some comment"
git remote add origin https://github.com/UserName/repository.git    --добавляем репозиторий
git push --set-upstream origin master                               --послед пуши - просто git push
спросит логин - ввести логин, без @
спросит пасс - ввести токен

да, токен не очень удобен, нужно через ssh ключ



1. задаём имя пользователя под которым мы будем работать (вносить все изменения в файлы)
git config --global user.name "Alexey Metelkov"

--global                      -настройки будут применяться к любому файлу, который мы редактируем
user.name "Alexey Metelkov"   -обновляем (прописываем) (своё)имя в двойных кавычках


прописываем (обновляем) нашу почту, так же в двойных кавычках - теперь знают как с нами связаться
git config --global user.email "my-email@email.com"


2. создаем локальный репозиторий (делаем на своем компьютере)
для этого переходим в ту папку которую хотим отдать под контроль гиту (пусть мы уже в ней)


git init    -инициализируем (делаем) репозиторий в нашей папке


3. создаем репозиторий на гитхаб
регистрируемся там и создаем пустой репозиторий, нажав на кнопку NEW - там веб интерфейс. 
(со временем интерфейс будет меняться и требования к безопасности будут изменяться)


теперь гит предложит как подключаться к репозиторию - берем https. выглядит примерно так
https://github.com/register-name/first-repo.git

register-name       -имя под которым зарегистрировались на гитхаб
first-repo.git      -созданный репозиторий через веб интерфейс, имя которое вписали, когда
                    нажимали на кнопку NEW

4. "соединяем" локальный и удаленный( на гитхабе) репозитории
git remote add origin url-repository

url-repository          -наш репозиторий на гитхабе

все выглядит так

git remote add origin https://github.com/register-name/first-repo.git


git status         -выводит текущий статус всех не сохранённых (не закомиченных) в репозитории
                   изменении. т.е. о тех файлах, чью версию мы изменили, но еще ен сохранили
                   эти изменения внутри гита (untracked file)


Добавляем все измененные файлы в гит (добавляем в индекс гита / stage area)
git add . 

добавляем в гит только файл readme.md
git add readme.md


после добавления в гит, команда git status  будет показывать какие файлы готовы к сохранению 
(будут сохранены в гит)


сохраняем (запоминаем) версию изменений файла/ов (коммит), которые находятся в индексе и 
присваиваем уникальный хэш, по которому можно будет вернуться на данную версию файла. 
так же важно писать описание! по этому описанию легче опознать, что было сделано
git commit -m "описание коммита"
git commit -m "изменил функцию, добавил проверки аргумента"


после коммита создастся некая контрольная точка, в которой будут храниться изменения (различия)
и на которую можно будет откатиться 


посмотреть информацию (историю) обо всех коммитах в данной ветке с их хэшами и комментариями
сортировка по дате/времени
git log



чтобы вернуться на прошлую версию файла (откатиться)
git checkout 46f23e87a9       -46f23e87a9   начальная часть хэша коммита на который откатываемся
                              но часть должна быть уникальной, всю писать не обязательно


чтобы перейти на другую ветку, только пишем не хэш, а имя ветки
git checkout <имя-ветки>
git checkout new-feature

git checkout master   -возвращаемся в ветку мастер


отправляем добавленные в индекс файлы на гитхаб (публикуем)
git push <имя репозитория> <ветка>


git push origin master      -origin - чтбы не писать url - т.к. любой локальный перозиторий 
                            знает свой удаленный
                            master - наша главная ветка - в нее коммитить после всех кодревью,
                            и тестов, быть осторожнее! можно все поломать

git push origin new-feature   -отправляем в гитхаб ветку "new-feature"



обновляем наш локальный репозиторий - скачиваем изменения с гитхаб - все коммиты в данной ветке,
которых еще нет в нашем локальном репозиториии (получаем ВСЕ коммиты и ВСЮ историю)
git pull <имя репозитория> <ветка>

git push origin master    -ну пока у нас так, т.к. нет других репозиториев и веток


ВЕТКА В ГИТ - последовательность коммитов которая имеет определенное имя (в любом, даже локальном
              репозитории есть минимум одна ветка, если она одна это master (или main))

смотрим какие ветки у нас есть в репозитории - выведем список локальных веток, которые доступны нам
сейчас в локальном репозитории
git branch    -звездочкой будет отмечена ветка на которой мы находимся

создать новую ветку (локальную) из той ветки, на которой мы находимся. лучше называть ветки так, чтобы
из названия было понятно, что в них будет содержаться. новая ветка создается на основе активной (на
которой мы находимся в момент создания)
git branch <имя-ветки>
git branch new-feature


соединяем ветки - после того как работа закончена и нужно переносить все в стабильную (мастер) ветку
и соединить работу со всеми остальными работами и изменениями. есть 2 способа:
способ первый:
нужно перейти на ту ветку КУДА мы хотим все слить. например соединяем все наработки из new-feature в МАСТЕРе
git checkout master     -переходим в мастер
git merge <имя-ветки>   
git merge new-feature    -производит слияние ветки new-feature с веткой МАСТЕР (т.к. мы в МАСТЕР перешли)
                         будет сделан один коммит (перезатрет старый МАСТЕР, новыми файлами из new-feature)

второй вариант:          -переносит все коммиты из рабочей ветки new-feature в ветку МАСТЕР
git rebase <имя-ветки>   -переместит коммиты из ветки new-feature в ветку, на которой находится пользователь (МАСТЕР)

git checkout master      -переходим в мастер
git rebase new-feature   -переместит коммиты из ветки new-feature в ветку, на которой находится пользователь (МАСТЕР)



чтобы скопировать репозиторий (чужой) к себе локально
переходим в папку где будут храниться копия репозитория и там 
git clone https://github.com/register-name/first-repo.git

https://github.com/register-name/first-repo.git    -чужой репо, который сохраняем у себя

так репо не инициализируем, мы его копируем, и чтобы работать в нем изменяем свои имя и
почту - см начало инструкции
(чтобы отправить на гитхаб изменения - нужно писать команды в консоли, сами изменения
загружаться не будут)



работа с vs code studio
(возможны проблемы с авторизацией, в начале нужно решить их)

создаем репозиторий на гитхабе
идем в vs code studio и (на главной стр, которая бывает при старте) выбираем CLONE GIT REPOSITORY
и копируем туда наш url из гитхаба https://github.com/register-name/first-repo.git
после студия предложит КУДА сохранить(нять) файлы на компьютеры - выберем директорию на диске
теперь будет предложено открыть репозиторий - открываем - но проект пока пуст - добавляем файлы
для подтверждения изменений - нажимаем значок плюс
для отклонения - на кривую стрелку (которая отменяет)
для подтверждения изменений - делаем коммит - пишем НАЗВАНИН КОММИТА - нажимаем на "галочку" подтверждения
чтобы ЗАСЛАТЬ НА ГИТХАБ - жмем в меню "три точки" и выбираем PUSH

для просмотра изменений - жать на значок М рядом с файлом

чтобы СТЯНУТЬ С ГИТХАБа изменения -меню "три точки" и выбираем PULL


чтобы синхронизировать локальный проект (добавить папку с файлами) с гитом - заслать в новый репозиторий
-открываем папку на локальном диске
найти INITIALIZE REPOSITORY - жмем
применяем все изменения (жмем плюс)
пишем название коммита
выполнить коммит (жмем галочку)
чтобы добавить проект на гитхаб - идем к репозиторию, там есть команда, копируем и вставляем в терминал
git remote add origin https://github.com/register-name/first-repo.git   (жмем ентер)
git push -u origin master    (жмем ентер) - это вторая команда

после все будет загружено на гитхаб


